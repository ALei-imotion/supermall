# 第一步：初始化工作
### 1、划分目录结构
  * assets：资源目录，一般包含img和css。
      normalize.css：是一种CSS reset的替代方案，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。
  
  * common：存放公共的.js文件，比如第三方库之类的

  * components：公共组件，下面可在细分为两个文件夹
      一个是common：指完全公共的组件，随便放到哪个项目中就能立即使用，不需要做任何修改
      一个是content：指对于该项目来说是公共的组件

  * network：网络请求相关

  * router：路由相关

  * store：状态管理相关

  * views：视图页面，用于存放该项目的不同模块中的视图

### 2、引入css文件
  * 创建最基本的base.css文件，在其中引入noamalize.css文件，然后在App.vue中导入base.css文件

### 3、配置别名
  * 对于脚手架2来说，需要在build文件夹中的 webpack.base.conf.js 文件中配置：
    ```
    resolve: {
      alias: {
        '@': resolve('src');
        'assets': resolve('src/assets'),
        'components': resolve('src/components'),
        'views': resolve('src/views'),
      }
    }
    ```

  * 对于脚手架3来说，需要在最外层目录中创建一个 vue.config.js 文件，在里面配置：
    ```
    module.exports = {
      configureWebpack: {
        resolve: {
          // extensions: ['.js', '.vue', '.json'],  // 对于脚手架3来说，不用在配置这个选项，默认创建时就已经配置好了(.js,.vue,.json)
          alias: {
            // '@': resolve('src'),   // 默认已经配置好了
            'assets': '@/assets',
            'common': '@/common',
            'components': '@/components',
            'network': '@/network',
            'views': '@/views',
          }
        }
      }
    }
    ```

### 4、为了便于项目中的样式的统一，需要在最外层目录中添加一个 .editorconfig 文件，用来限制样式
    ```
    root = true

    [*]
    charset = utf-8
    indent_style = space
    indent_size = 2
    end_of_line = lf
    insert_final_newline = true
    trim_trailing_whitespace = true
    ```

# 第二步：导入之前创建好的tabbar组件
### 1.添加组件
  * 在components文件夹中创建目录，common/tabbar，里面包含两个组件(TabBar.vue和TabBarItem.vue)
  * 在components文件夹中创建目录，content/maintabbar，里面包含一个组件(MainTabBar.vue)

### 2.导入组件
  * 在App.vue中导入tabbar的最外层组件 MainTabBar (import MainTabBar from 'components/content/maintabbar/MainTabBar')
  * 将MainTabBar组件在components中注册一下，在template模板中加入<main-tab-bar></main-tab-bar>标签

### 3.在views文件夹中创建多个视图目录，主要由tabbar里面包含的模块决定
  * 比如此项目就包含4个模块，分别是home(首页),category(分类),cart(购物车),profile(我的)

### 4.创建路由
  + 在router文件夹中创建index.js文件
    + 基本步骤
      - 1.先导入基本的vue和vue-router 
      - 2.安装插件(Vue.use(VueRouter))
      - 3.定义路由，配置路由映射
          ```
          const routes= [
            {
              path: '',
              redirect: '/home' // 路由重定向，目的是为了使网页一打开就能显示首页内容
            },
            {
              path: '/home',
              component: Home
            },
            ...
          ]
          ```
      - 4.定义路由对象
          ```
          const router = new VueRouter({
            routes,
            mode: 'history',
          })
          ```
      - 5.导出路由对象
    + 将views中的视图模块(路由懒加载方式)导入，以便在定义路由时使用
      ```
      const Home = () => import('views/home/Home')
      const Category = () => import('views/category/Category')
      ...
      ```

### 5.导入路由
  + 在main.js文件中导入路由并且将它添加到全局的Vue实例中
  + 在App.vue的template中添加标签<router-view></router-view>

# 第三步：制作首页视图
### 1.创建导航栏组件
  + 由于大多数的移动端的导航栏组件基本类似，都大致可划分为3块，即左右两个固定宽度的标签以及中间剩余部分的文字标签。所以可以将它封装成一个完全独立的组件。
  + 在components/common目录下创建一个navbar文件夹，创建组件NavBar.vue
  + 由于要做到可以随意设置导航栏里的内容，所以采用插槽的方式设置
  + 由于直接对插槽进行样式设置不太合理，所以在每个插槽外面单独封装一个div给它包裹起来，对div进行样式设置
  + 对导航栏采用flex布局
    ```
    .nav-bar {
      display: flex;
      height: 44px;   // 导航栏的高度一般都为44px
      line-height: 44px;
      text-align: center;
      box-shadow: 0 1px 1px rgba(100, 100, 100, 0.1); // 给div设置阴影
    }

    .left,
    .right {
      width: 60px;
    }

    .middle {
      flex: 1;
    }
    ```
### 2.在首页视图中使用导航栏组件
  + 在views/home目录下的Home.vue组件中导入导航栏组件
    import NavBar from 'components/common/navbar/NavBar';
  + 将该组件在components中注册
  + 给该导航栏插入对应的内容
    - 由于该首页导航栏只有中间部分有内容，所以只需要一个标签插入即可,将它绑定到对应的插槽上
      <nav-bar class="home-nav">
        <div slot="middle">购物街</div>
      </nav-bar>
  + 为了保证导航栏组件的独立性，不选择直接在导航栏组件中设置背景颜色样式，而是在引入nav-bar组件的地方，给组件添加一个class属性，用来单独设置
    ```
    .home-nav {
      background-color: var(--color-tint);
      color: #fff;
    }
    ```
### 3.首页视图向服务器请求数据
  + 知识点：函数调用过程
    - 函数调用 -> 压入函数栈（保存函数调用过程中的所有变量）
    - 函数调用结束 -> 弹出函数栈（释放函数所有的变量，即内存会被回收掉）
  + 1.先将之前封装好的request.js文件拷贝到network目录下
  + 2.为了保证每个页面请求的数据不会混乱，所以可以选择为每个页面单独建立请求文件
  + 3.建立home.js文件，在里面封装一个用来请求首页所有数据的函数接口（getHomeMultidata）
  + 4.在Home.vue中导入封装好的home.js
  + 5.因为我们需要在页面一打开就有数据出来，所以可以在生命周期钩子created()中调用数据请求接口，
    即保证在页面一加载就执行程序获得数据
  + 6.由于getHomeMultidata返回的是一个Promise，所以可以在.then()中获取到请求的数据
  + 7.为了能够保证数据一直存在，所以用一个变量来保存它（在data中声明一个变量）
  + 8.为了能使首页中的各模块数据好区分开来，所以可以用多个变量分别来保存
  + 9.此时主要是请求的轮播图和推荐信息的数据
  
### 4.首页轮播图界面的展示
  + 1.因为轮播图算是一个公共组件，所以在components下common目录下创建swiper文件夹
  + 2.创建一个Swiper.vue组件：该组件表示轮播图最外层的容器；
      创建一个SwiperItem.vue组件：该组件表示轮播图中的每个元素，这里指图片
  + 3.在Home组件中导入Swiper，SwiperItem组件并在components中注册组件
    ```
    // import Swiper from "components/common/swiper/Swiper";
    // import SwiperItem from "components/common/swiper/SwiperItem";
    import { Swiper, SwiperItem } from "components/common/swiper"; // 这里导入的其实是index.js文件中export出来的模块
    ```
  + 4.由于需要动态更新元素，所以采用插槽的方式传值
    - 在Swiper组件中有两个插槽，第一个插槽是用来传入图片的插槽，这里我们会在Home组件中调用Swiper时给它传入SwiperItem组件，在SwiperItem组件中会传入一个超链接a，确保在点击图片后能够跳转到对应界面，然后在a标签中添加一个img标签，用来显示图片;另一个插槽“indicator”是用来动态更新图片中间下方的白色小圆点，它会根据有几张图片加载进来来动态创建小圆点并将小圆点与对应的图片进行绑定
    - 由于需要做到动态更新，不能写死，所以采用v-for来遍历之前请求到的轮播图数据,动态创建<swiper-item>组件
    - ```
      <swiper>
        <swiper-item v-for="item in banners">
          <a :href="item.link">
            <img :src="item.image" alt="" />
          </a>
        </swiper-item>
      </swiper>
      ```
  + 5.为了避免Home组件中的代码逻辑变得更复杂，便于后期维护与阅读，所以可以将swiper组件在进行一次封装，封装成HomeSwiper组件。由于封装的HomeSwiper组件只是为了在home中使用，所以可以直接在views/home目录下在创建一个文件夹childComponents用来存放只属于home页面中的组件，没必要到最外层的components目录下创建
  + 6.在HomeSwiper组件中调用Swiper组件和SwiperItem组件
    ```
    <template>
      <swiper>
        <swiper-item v-for="item in banners">
          <a :href="item.link">
            <img :src="item.image" alt="" />
          </a>
        </swiper-item>
      </swiper>
    </template>

    <script>
    // import Swiper from "components/common/swiper/Swiper";
    // import SwiperItem from "components/common/swiper/SwiperItem";
    import { Swiper, SwiperItem } from "components/common/swiper";

    export default {
      name: "HomeSwiper",
      props: {  // 由于本身是没有banners参数的，所以需要靠父组件给它传递
        banners:  {
          type: Array,
          default() {
            return []
          }
        }
      },
      components: {
        Swiper,
        SwiperItem,
      }
    };
    </script>

    <style>
    </style>
    ```
  + 7.在Home组件中调用HomeSwiper组件，并将请求到的轮播图数据传递给子组件HomeSwiper
    ```
    <template>
      <div id="home">
        <nav-bar class="home-nav"><div slot="middle">购物街</div></nav-bar>
        <home-swiper :banners="banners"></home-swiper>
      </div>
    </template>
    ```

### 5.首页推荐信息界面的展示
  + 1.在childComponents目录下创建子组件HomeRecommendView
  + 2.在Home组件中导入HomeRecommendView组件
  ```
  import HomeRecommendView from "./childComponents/HomeRecommendView";
  ```
  + 3.在HomeRecommendView组件中添加如下标签，为了避免层级太多，代码过于复杂，采用v-for来遍历数组，动态创建多个推荐信息标签
    ```
    <template>
      <div class="recommend">
        <div class="recommend-item" v-for="item in recommends">
          <a :href="item.link">
            <img :src="item.image" alt="">
            <div>{{item.title}}</div>
          </a>
        </div>
      </div>
    </template>
    ```
  + 4.给标签recommend-item设置样式，这里采用水平均匀分布
  + 5.由于v-for遍历的recommends中的内容是在父组件Home中请求的，所以这里需要父组件将recommends的数据传递给子组件HomeRecommendView，同时在子组件中应该建立props属性来接父组件传过来的值
  ```
  <script>
  export default {
    name: "HomeRecommendView",
    props: {
      recommends: {
        type: Array,
        default() {
          return []
        }
      }
    }
  }
  </script>
  ```
  + 6.Home组件中调用HomeRecommendView组件，并将recommends数据传递到子组件
  ```
  <template>
    <div id="home">
      <nav-bar class="home-nav"><div slot="middle">购物街</div></nav-bar>
      <home-swiper :banners="banners"></home-swiper>
      <home-recommend-view :recommends="recommends"></home-recommend-view>
    </div>
  </template>
  ```

### 6.首页本周流行界面的展示
  + 1.创建组件HomeFeatureView
  + 2.由项目的最终演示成果可知，本周流行这部分展示的其实是一张图片，并不是一个个小的组件组成的，所以直接在模板中添加一个根标签div，在根标签中再加一个img标签即可；但是由于当点击图片之后，界面会跳转到本周流行的商品界面中，所以说，不能单纯的加一个img标签就好了，这里我们选择在img的外层套一个a标签，这样点击图片后就能跳转了
  ```
  <template>
    <div class="feature">
      <a href="https://act.mogujie.com/zzlx67">
        <img src="~assets/img/home/recommend_bg.jpg" alt="" />
      </a>
    </div>
  </template>
  ```
  + 3.在Home组件中导入HomeFeatureView组件并使用
  + 4.从显示效果可以看出，图片大小太大，超出了屏幕界限，所以在HomeFeatureView组件中设置图片的样式
  + 5.此时图片已经能够正常显示，点击也会正常跳转
  + 6.此时滚动右侧的滑动条会发现，当我们在向下滚动时，最上方的导航栏组件也会一起滑动，从而被隐藏，这与我们的初衷就不符合了，本意是想让它一直固定在最上方，不随滑动条的滚动而滚动
  + 7.所以在Home组件中设置导航栏的样式，将它的位置改为固定不移动
  ```
  .home-nav {
      background-color: var(--color-tint);
      color: #fff;

      position: fixed;
      left: 0;
      right: 0;
      top: 0;
  }
  ```
  + 8.设置位置之后，navbar会被轮播图的图片给挡住，从而不可见，所以需要在样式中设置层级：z-index:9
  + 9.设置层级之后，导航栏组件能显示出来，但是可以发现它会遮盖一下轮播图组件，所以我们给最外层的根标签设置样式：padding-top：44px；即让它距离顶部的间距和导航栏组件的高度一致，这样就能正常显示了。
  + 10.为了能够看到本周流行界面下方的内容，这里可以简单的添加一个无序列表来占位，便于查看滚动的时候，之前设置的样式有没有生效。

### 7.首页tabControl界面的展示
  + 1.对于本周流行界面下方的tabControl界面来说，这是一个可以重复利用的组件，因为在分类页面中也可以复用，只需要重新替换下里面的文本内容即可。所以选择将tabControl组件独立出来，放到components文件夹下，又因为这个组件会偏向于只针对该项目，所以将它放在components/content目录下，做成一个对于该项目来说独立的组件
  + 2.创建完TabControl组件后，这里可以有两种选择方式；第一种就是采用插槽的方式，类似导航栏组件的做法，写上3个插槽；第二种写法就是用div嵌套span标签的方式来实现
  + 3.使用v-for来遍历父组件传过来的titles的内容，动态创建3个嵌套了span标签的div
  ```
  <div class="tab-control">
    <div v-for="item in titles">
      <span>{{ item }}</span>
    </div>
  </div>

  <!-- script中写入 -->
  props: {
    titles: {
      type: Array,
      default() {
        return [];
      },
    },
  },
  ```
  + 4.Home组件中导入TabControl组件并使用，给子组件传入相应的值
  ```
  <tab-control class="tab-control" :titles="['流行','新款','精选']"></tab-control>
  ```
  + 5.打开网页，可以看见已经能够显示出来了，下面就需要调整样式了。给子组件添加一个class属性“item-tab-control”，设置它的样式以及它的根元素的样式
  ```
  .tab-control {
    display: flex;
    text-align: center;
    font-size: 15px;
    background-color: #fff;
  }

  .tab-control-item {
    flex: 1;
    height: 40px;
    line-height: 40px;
  }
  ```
  + 6.样式正常后，接下来该实现选中文本标签后颜色的改变以及画出文本下方的横线，对于横线，可以采用css的boder-bottom属性，即设置一个底边的样式就可以实现
  + 7.由于要实现颜色的改变，这里给每个标签添加一个index属性，这样就可以根据选中标签时的下标来判断到底哪个标签该变成粉色，所以在遍历时需要做一些改变，同时添加一个class属性“active”来判断到底哪个标签被激活，通过判断标签的index和当前的currentIndex是否一致来决定是否给该标签所属的div添加一个active属性
  ```
  <div class="tab-control">
    <div
      v-for="(item, index) in titles"
      class="tab-control-item"
      :class="{ active: index == currentIndex }"
      @click="itemClick(index)"
    >
      <span>{{ item }}</span>
    </div>
  </div>

  data() {
    return {
      currentIndex: 0,
    };
  },
  methods: {
    itemClick(index) {
      this.currentIndex = index;
    }
  }

  .tab-control-item span {//为了避免下方横线离文本太近，添加一个间距
    padding: 5px;
  }

  .active {
    color: var(--color-high-text);
  }

  .active span {
    border-bottom: 2px solid var(--color-tint);
  }
  ```
  + 8.此时，当我们滚动页面时，其它一切正常，但是会发现tabControl也会随着一起滚动，与我们想要的效果不符，这里我们可以使用css的position：sticky以及top：44px来实现将tabControl固定在离顶部44px的位置，不再随着页面滚动而隐藏掉。但是后期会选择用其它方式来实现，因为有些浏览器对position的这个属性不兼容。

### 8.请求首页商品列表（流行、新款、精选）的数据
  + 1.由于商品列表的数据非常多，为了避免重复请求带来的性能浪费，所以选择一次性的请求全部数据，用一个对象变量（goods）来保存它们。
    - 因为里面的数据分为了三大块，所以在goods里面创建了三个对象，分别用来保存对应模块的数据内容
    - 在各自模块中又创建了两个键值，page和list，list是个数组，主要用来存放对应的数据，page是页码，用来判断当前页面显示了几页的数据（这里我们假设一页默认含有30个商品数据，，如果我们滑到最底部后不再选择下拉加载新的数据时，就只会显示30个商品数据，如果选择了下拉加载新的数据，此时page就变成2，list中的数据就会变成两页的商品数据，即60个商品）
    - 同时加上一个page键值的目的也是为了区分开不同模块的加载数量，比方说pop页加载的page为3，则list应为[90]；new页加载的page为2，则list应为[60]；sell页加载的page为1，则list应为[30]；这样当我们在三个页面中来回切换时，就可以明确的知道请求了多少的数据量，不必再频繁的点击一个页面就去请求一次数据。这里我们只需要做到在一个页面有下拉刷新的行为时才会去请求一次数据
  + 2.由于要请求数据了，所以可以在网络请求模块中再重新封装一个函数接口，用来请求商品数据；因为需要知道具体请求的是哪个页面的内容以及请求多少页的内容，所以需要保证该函数有两个传参（type，page）
  ```
  export function getHomeGoods(type, page) {
    return request({
      url: 'home/data',
      params: {
        type,
        page
      }
    })
  }
  ```
  + 3.在Home组件中导入该函数接口，并在created钩子函数中实现
  + 4.因为需要做到在页面一加载就将流行/精选/新款的第一页内容获取到，所以这里需要调用三次函数接口
  ```
  getHomeGoods('pop', 1).then((res) => {console.log(res)}
  getHomeGoods('new', 1).then((res) => {console.log(res)}
  getHomeGoods('sell', 1).then((res) => {console.log(res)}
  ```
  + 5.如果像上面这样直接在created中调用接口，如果次数较少到是无所谓，但当次数一旦频繁起来，就会使得代码逻辑变得复杂冗余，所以可以选择对这些请求函数的接口在封装一层方法，将它们都放到methods中实现，只需要在created中调用本身的方法即可
  ```
  created() {
    // 1.请求多个数据
    this.get_home_multidata();
    // 2.请求商品数据
    this.get_home_goods("pop");
    this.get_home_goods("new");
    this.get_home_goods("sell");
  },
  methods: {
    get_home_multidata() {
      getHomeMultidata().then((res) => {
        this.banners = res.data.banner.list;
        this.recommends = res.data.recommend.list;
      });
    },

    get_home_goods(type) {
      const page = this.goods[type].page + 1;
      getHomeGoods(type, page).then((res) => {
        // 方法一
        // for (let n of res.data.list) {
        //   this.goods[type].list.push(n);
        // }
        // 方法二
        // ...可以将数组中的数据解析遍历，并一个一个的取出来
        this.goods[type].list.push(...res.data.list);
        this.goods[type].page += 1;
      });
    },
  }
  ```
  + 6.此时可以对方法进行上述的封装，主要是为了实现类型和页数的动态指定。
    - 在getHomeGoods被执行前，获取到属于该类型的页码，对其进行加一，目的是为了动态指定页数（由于默认获取的页数是第0页，所以此时获取的就是第一页的内容）
    - 在getHomeGoods被执行后，获取到属于该类型的页码，对其进行加一，此时page就变成了1，这样在执行后续的下拉刷新时，就可以获取到第二页的内容了，同时由于之前获取到的第一页的内容已经push到list数组中了，所以在获取了第二页内容后，将它们push追加到list数组中即可

### 9.商品列表数据的展示
  + 1.考虑到组件的复用性，选择将组件创建在components/content目录下，目的是为了能够在该项目中多处复用。
  + 2.创建一个最外层的大组件GoodsList，然后里面会嵌套多个小组件GoodsListItem
  + 3.通过Home组件给GoodsList组件传入数据，在GoodsList组件中动态创建GoodsListItem组件，用v-for来遍历传过来的goods，根据goods的大小来决定创建几个GoodsListItem组件，同时将遍历出来的item传给GoodsListItem子组件，这里item是个对象（Object）
  + 4.在GoodsListItem组件中实现具体的显示，由最终效果图可知，里面含有一个img标签用来显示图片，一个p标签用来显示对图片的描述，一个span标签用来显示价格，一个span标签用来显示被收藏的数量
  ```
  <template>
    <div class="goods-item">
      <img :src="goodsItem.show.img" alt="" srcset="" />
      <div class="goods-info">
        <p>{{ goodsItem.title }}</p>
        <span class="price">{{ goodsItem.price }}</span>
        <span class="collect">{{ goodsItem.cfav }}</span>
      </div>
    </div>
  </template>

  <script>
  export default {
    name: "GoodsListItem",
    props: {
      goodsItem: {
        type: Object,
        default() {
          return {};
        },
      },
    },
  };
  </script>
  ```
  + 5.此时信息已经能够显示了，接下来设置样式。
    - 先设置最外层的样式，这里设置图片与该组件的下边界的距离为44px，即表示图片下方用来显示信息的文字区域的高度为44px，同时给它设置相对定位布局，方便后面文字的绝对定位布局，如果不设置相对定位的话，那么后面文字的绝对定位则是根据窗口的位置来设置的
    ```
    .goods-item {
      padding-bottom: 40px;
      position: relative;
    }
    ```
    - 设置图片的样式，宽度100%填充，高度自适应，为了好看，加一个圆角
    ```
    .goods-item img {
      width: 100%;
      border-radius: 5px;
    }
    ```
    - 接着设置下方文字显示区域的样式，这里采用绝对定位，使得它能够依据之前设定的相对定位来找位置
    ```
    .goods-info {
      font-size: 12px;
      position: absolute;
      bottom: 5px;
      left: 0;
      right: 0;
      overflow: hidden;
      text-align: center;
    }
    ```
    - 设置p标签的样式，让它能够显示在一行里面，超出一行的用...给它隐藏起来
    ```
    .goods-info p {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-bottom: 3px;
    }
    ```
    - 设置价格的样式，这里主要是字体颜色以及价格标签的一个位置
    ```
    .goods-info .price {
      color: var(--color-high-text);
      margin-right: 20px;
    }
    ```
    - 设置收藏标签的样式，这里对整个标签采用相对布局，对标签里的伪元素图标采用绝对定位
    ```
    .goods-info .collect {
      position: relative;
    }

    /* 采用伪元素的方式，引入一个收藏图标 */
    .goods-info .collect::before {
      content: "";
      position: absolute;
      left: -15px;
      top: -1px;
      width: 14px;
      height: 14px;
      background: url("~assets/img/common/collect.svg") 0 0/14px 14px;
    }
    ```
  + 6.为了达到美观效果，这里一行只显示两个GoodsListItem，所以可以采用flex布局。justify-content 属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间
  ```
  .goods {
    /* 由于直接采用flex布局的话，默认是会挤在一行显示，不换行 */
    display: flex;
    /* 这里使用flex-wrap：wrap 表示允许换行，再结合给子组件设定的宽度48%就可以达到换行效果 */
    flex-wrap: wrap;
    /* 均匀排列每个元素，每个元素周围分配相同的空间 */
    justify-content: space-around;
    padding: 2px;
  }

  .goods-item {
    /* padding-bottom:指一个元素在内边距区域（指一个元素的内容与边框之间的区域）中下方的高度 */
    padding-bottom: 40px;
    position: relative;
    width: 48%;
  }
  ```

### 10.tabControl点击切换商品列表信息
  + 1.为了达到可以动态切换商品列表信息，这里在调用GoodsList组件时就不能在采用之前的固定写法（<goods-list :goods="goods['pop'].list"></goods-list>）了
  + 2.为了明确的知道需要显示那个列表的内容，这里使用之前在tabControl组件中实现的方法，将里面遍历时对应的index传出来，给到父组件。这就需要使用到自定义事件了
  ```
  methods: {
    itemClick(index) {
      this.currentIndex = index;
      this.$emit("tabItemClick", index);
    }
  }
  ```
  + 3.然后在父组件Home中去监听子组件中创建的事件（v-on:tabItemClick=""），并在父组件中创建一个方法（tabClick），将子组件传过来的index做一个判断并赋予相应的值（在data中创建一个变量，用来表示需要传递的类型，默认给定“pop”类型）
  ```
  <tab-control class="home-tab-control"
    :titles="['流行', '新款', '精选']"
    @tabItemClick="tabClick"
  ></tab-control>

  <goods-list :goods="goods[currentType].list"></goods-list>

  tabClick(index) {
    switch (index) {
      case 0:
        this.currentType = "pop";
        break;
      case 1:
        this.currentType = "new";
        break;
      case 2:
        this.currentType = "sell";
        break;
      default:
        break;
    }
  },
  ```
  + 4.由于直接在goods后面写一长串字符不好看，所以采用几个计算属性来替代那一长串表达式
  ```
  <goods-list :goods="showGoods"></goods-list>

  computed: {
    showGoods() {
      return this.goods[this.currentType].list;
    }
  }
  ```
  + 5.到此为止，首页需要显示的内容、布局以及实现方法都已经基本实现了

### 11.BetterScroll的基本使用
  + BetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll (opens new window)的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化
  + 1.为了能够在移动端也有个好的滑动效果，这里选择了BetterScroll滑动插件。因为PC端浏览器自带的滑动插件运行到移动端时，效果会大打折扣，容易出现卡顿
  + 2.安装BetterScroll插件
    - BetterScroll 2.X 里面，我们将 1.X 耦合的 feature 拆分至插件，以达到按需加载、减少包体积的目的。因此，@better-scroll/core 只提供了最核心的滚动能力。如果想要实现上拉刷新、下拉加载的功能，你需要使用对应的插件。
      - npm install @better-scroll/core --save
    - 安装具备所有插件能力的 BetterScroll：
      - npm install better-scroll --save
  + 3.BetterScroll的使用：
    - 基础滚动：如果你只需要一个拥有基础滚动能力的列表，只需要引入 core。
    ```
    import BScroll from '@better-scroll/core'
    let bs = new BScroll('.wrapper', {
      // ...... 详见配置项
    })
    ```
    - 增强型滚动：如果你需要一些额外的 feature。比如 pull-up，你需要引入额外的插件。
    ```
    import BScroll from '@better-scroll/core'
    import Pullup from '@better-scroll/pull-up'

    // 注册插件
    BScroll.use(Pullup)

    let bs = new BScroll('.wrapper', {
      probeType: 3,
      pullUpLoad: true
    })
    ```
    - 全能力的滚动：如果你觉得一个个引入插件很费事，我们提供了一个拥有全部插件能力的 BetterScroll 包。它的使用方式与 1.0 版本一模一样，但是体积会相对大很多，推荐按需引入。
    ```
    import BScroll from 'better-scroll'

    let bs = new BScroll('.wrapper', {
      // ...
      pullUpLoad: true,
      wheel: true,
      scrollbar: true,
      // and so on
    })
    ```
  + 4.在components/common目录下创建文件夹scroll，用来存放Scroll组件。在Scroll组件中导入BetterScroll插件，然后按照标准模板创建HTML部分，主要包含两个部分，一个是最外层的warpper，一个里面的内容区content，并且对于该插件来说，它的结构只允许存在这两级目录，如果我们想要实现指定区域的滚动，只需要在里面添加一个插槽，到时候将插槽的内容替换即可。
  ```
  <template>
    <!-- BetterScroll默认处理容器(wrapper)的第一个子元素(content)的滚动，其它的元素都会被忽略 -->
    <div class="wrapper" ref="wrapper">
      <div class="content">
        <slot></slot>
      </div>
    </div>
  </template>
  ```
  + 5.模板创建完毕后，就应该初始化better-scroll了，这里选择在mounted()钩子函数中实现，为什么不选择在created()中实现呢？因为在初始化better-scroll时必须确保父元素和子元素的内容已经正确渲染了。
  ```
  mounted() {
    /**
     * 尽量避免使用document.querySelector()去获取元素，因为这种方法默认获取的是第一个出现该名字的元素
     * 如果有多个地方出现了重名的情况，那么通过这种方式获取的元素就不一定是我们想要的那个元素
     */
    // this.scroll = new BScroll(document.querySelector(".wrapper"));

    /**
     * ref如果是绑定在组件中，那么通过 this.$refs.refname 获取到的是一个组件对象
     * ref如果是绑定在普通的元素中，那么通过 this.$refs.refname 获取到的是一个元素对象
     */
    this.scroll = new BScroll(this.$refs.wrapper, {});
  },
  ```
  + 6.在Home组件中导入Scroll组件并使用,这里只需要对首页导航栏之下的部分实现滚动就行了
  ```
  <scroll class="scroll">
    <home-swiper :banners="banners"></home-swiper>
    <home-recommend-view :recommends="recommends"></home-recommend-view>
    <home-feature-view></home-feature-view>

    <tab-control
      class="home-tab-control"
      :titles="['流行', '新款', '精选']"
      @tabItemClick="tabClick"
    ></tab-control>

    <goods-list :goods="showGoods"></goods-list>
  </scroll>
  ```
  + 7.给scroll设置一个高度，这里也就是给wrapper设置一个高度，至于里面的content的高度则是由content里面包含的内容自动填充。由于需要将scroll的位置绝对定位，所以需要将scroll的父元素home设置成相对定位，同时设置home的高度为可视高度（100vh），那么scroll的高度就是home的可视高度减去44px再减49px。
  ```
  #home {
    /* padding-top: 44px; */
    height: 100vh;
    position: relative;
  }

  .scroll {
    overflow: hidden;
    position: absolute;
    top: 44px;
    bottom: 49px;
    left: 0;
    right: 0;
  }
  ```
  + 8.此时已经可以正常滚动了，但是此时会发现，所有的点击事件不在生效，这是因为没有配置的原因，因为better-scroll插件默认是不支持click事件的。同时原来设置的home-tab-control的中样式（position: sticky; top: 44px;）也不在生效,这些都放在之后再处理。

### 12.BackTop组件的封装以及显示和隐藏
  + ==在vue中，组件是不能够直接监听事件的（<back-top @click="backClick"/>），不会生效，只有原生的元素才可以直接监听事件，如果想要实现组件的事件监听，必须在后面加上修饰符（.native：监听组件的原生事件）才可以实现（<back-top @click.native="backClick"/>）==
  + 1.为了实现点击回到顶部的图标时能够让页面回到顶部，需要做一个单独的组件，该组件对于该项目来说是能够复用的，所以在components/content目录下创建backTop文件夹，在里面创建组件BackTop.vue
  + 2.由于该组件只是一张简单的图片，所以设置非常简单，只需要将目标图片导入进来即可
  ```
  <img src="~assets/img/common/top.png">
  ```
  + 3.在Home组件中导入BackTop组件。由于该图标是不随页面滚动的，所以它的层级和Scroll组件层级一致
  ```
  <template>
    <div id="home" class="wrapper">
      <nav-bar class="home-nav"><div slot="middle">购物街</div></nav-bar>

      <scroll class="scroll" ref="bscroll">
        <home-swiper :banners="banners"></home-swiper>
        <home-recommend-view :recommends="recommends"></home-recommend-view>
        <home-feature-view></home-feature-view>
        <tab-control
          class="home-tab-control"
          :titles="['流行', '新款', '精选']"
          @tabItemClick="tabClick"
        ></tab-control>
        <goods-list :goods="showGoods"></goods-list>
      </scroll>

      <back-top @click.native="backClick"></back-top>
    </div>
  </template>
  ```
  + 4.此时图标已经能够显示，接下来设置图标的样式，由于该图标的位置相对来说是固定不动的，所以可以采用fixed定位，接下来再给图片设置一个大小就可以正常显示了。为了实现监听该图标组件的点击事件，需要在@click后面追加修饰符(.native)。
  + 5.在Home组件的methods属性中实现backClick方法。该方法的原理是：点击图标，来操控better-scroll的滚动，所以我们的首要任务就是要先获取到Scroll组件，获取了之后再通过Scroll组件自带的或者我们自定义的属性或方法来实现滚动等操作。
  ```
  backClick() {
      // 可以通过this.$refs.bscroll直接访问到scroll组件中的属性以及方法
      // console.log(this.$refs.bscroll.message);
      this.$refs.bscroll.scrollTo(0, 0, 500);
  },
  ```
  + 6.在Scroll组件定义一个回到顶部的方法，以便供Home组件调用
  ```
  methods: {
    scrollTo(x, y, time = 300) {// 如果在调用时未传入time参数，则采用默认的300ms
      this.scroll.scrollTo(x, y, time);
    },
  },
  ```
  + 7.在前面步骤实现了BackTop组件的显示，但是这个显示是一直存在的，是不合理。所以我们需要实现让它在滚动到一定位置时显示出来，快回到顶部时就隐藏起来。可以调用better-scroll插件自带的事件监听方法来实现（this.scroll.on("scroll", (position)=> {})）
  + 8.由于要想实现滚动监听，就必须设置BScroll对象的probeType属性才行，否则监听是不会生效的。但是考虑到如果直接将probeType的属性写死的话，那么会对性能造成很大的浪费，毕竟有的地方滚动需要监听滚动事件，而有的地方则是不需要的，所以这里不能直接写死，采用传参的方式，通过在调用Scroll组件的地方设置probeType属性来决定是否要监听滚动事件
  ```
  props: {
    probeType: {
      type: Number,
      default: 0,
    },
  },

  mounted() {
    // 1.创建BScroll对象
    this.scroll = new BScroll(this.$refs.wrapper, {
      click: true,
      probeType: this.probeType,
    });

    // 2.监听滚动的位置
    this.scroll.on("scroll", (position) => {
      // console.log(position);
      this.$emit("scroll", position); // 通过自定义事件将位置参数发送出去
    });
  },
  ```
  + 9.在Home组件中调用Scroll组件时，注意传入需要的参数(:probeType="3")，如果不加冒号的话，则传过去的值是个字符串形式，加冒号的话则是Number形式
  ```
  <scroll
    class="scroll"
    ref="bscroll"
    :probe-type="3"
    @scroll="contentScroll" // 监听自定义事件scroll
  >
    <home-swiper :banners="banners"></home-swiper>
    <home-recommend-view :recommends="recommends"></home-recommend-view>
    <home-feature-view></home-feature-view>

    <tab-control
      class="home-tab-control"
      :titles="['流行', '新款', '精选']"
      @tabItemClick="tabClick"
    ></tab-control>

    <goods-list :goods="showGoods"></goods-list>
  </scroll>
  ```
  + 10.在Home组件中实现方法contentScroll，用来判断滑动的位置，从而决定是否显示BackTop组件，这里是通过v-show来实现的，设置一个变量isShowBackTop，默认初始化为false；在方法中判断滚动的位置，当position.y的值大于1000时，将isShowBackTop置为true，小于1000时则置为false；而且由于position.y的值是个负值，所以这里得取它的绝对值才行
  ```
  <back-top @click.native="backClick" v-show="isShowBackTop"></back-top>

  data() {
    return {
      banners: [],
      recommends: [],
      goods: {
        pop: { page: 0, list: [] },
        new: { page: 0, list: [] },
        sell: { page: 0, list: [] },
      },
      currentType: "pop",
      isShowBackTop: false,
    };
  },
  methods: {
    contentScroll(position) {
      // console.log(position);
      this.isShowBackTop = (-position.y) > 1000;
    },
  },
  ```

### 13.上拉加载更多内容的实现
  + 1.为了实现上拉事件，首先得在Scroll组件中监听上拉事件，与之前的设置同理，为了不写死，还是按照之前的做法来实现，同时封装一个方法finishPullUp，以供外部调用
  ```
  props: {
    probeType: {
      type: Number,
      default: 0,
    },
    pullUpLoad: {
      type: Boolean,
      default: 0,
    }
  },

  mounted() {
    // 3.监听上拉事件
    this.scroll.on("pullingUp", () => {
      this.$emit("pullingUp");
    })
  },

  methods: {
    finishPullUp() {
      this.scroll.finishPullUp();
    }
  },
  ```
  + 2.在Home组件中调用Scroll组件的地方监听Scroll组件中的自定义事件pullingUp，并给它实现一个方法loadMore，同时给Scroll组件传参（:pull-up-load="true"），由于当我们滑动到底部时，肯定会有请求刷新数据的操作，所以这里可以直接指定成true
  ```
  <scroll
    class="scroll"
    ref="bscroll"
    :probe-type="3"
    :pull-up-load="true"
    @scroll="contentScroll"
    @pullingUp="loadMore"
  >
    <home-swiper :banners="banners"></home-swiper>
    <home-recommend-view :recommends="recommends"></home-recommend-view>
    <home-feature-view></home-feature-view>

    <tab-control
      class="home-tab-control"
      :titles="['流行', '新款', '精选']"
      @tabItemClick="tabClick"
    ></tab-control>

    <goods-list :goods="showGoods"></goods-list>
  </scroll>

   methods: {
    loadMore() {
      this._getHomeGoods(this.currentType)
    },

    _getHomeGoods(type) {
      const page = this.goods[type].page + 1;
      getHomeGoods(type, page).then((res) => {
        // console.log(res);
        // 方法一
        // for (let n of res.data.list) {
        //   this.goods[type].list.push(n);
        // }

        // 方法二
        // ...可以将数组中的数据解析遍历，并一个一个的取出来
        this.goods[type].list.push(...res.data.list);
        this.goods[type].page += 1;

        this.$refs.bscroll.finishPullUp();
      });
    },
   }
  ```
  + 3.如果我们不指定finishPullUp，那么上拉刷新就只会执行一次，因为代码是不知道你到底是在时候结束的上拉加载行为，所以在每次触发pullingUp钩子后，就应该主动的调用 finishPullUp()，告诉BetterScroll准备好了下一次的pullingUp钩子。

### 14.解决滚动区域的Bug（主要表现在下拉滚动时有时候会卡顿一会，不会立即顺滑的向下滚动）
  + Better-Scroll在决定有多少区域可以滚动时, 是根据scrollerHeight属性决定
    - scrollerHeight属性是根据存放Better-Scroll的content中的子组件的高度来决定的
    - 但是在我们的首页中, 刚开始在计算scrollerHeight属性时, 是没有将图片计算在内的，因为请求图片资源时，有可能会因为网络问题或者服务器不稳定的问题，从而导致获取到资源的速度过慢，也就是图片还没有请求回来，scrollerHeight已经计算好了，所以计算出来的可滚动区域的高度是错误的
    - 后来图片加载进来之后有了新的高度, 但是scrollerHeight属性并没有进行更新，所以滚动就出现了问题
  + 如何解决这个问题呢?
    - 监听每一张图片是否加载完成, 只要有一张图片加载完成了, 执行一次refresh()
  + 如何监听图片加载完成了?
    - 原生的js监听图片: img.onload = function() {}
    - Vue中监听: @load='方法',在方法中调用scroll的refresh()
  + 如何将GoodsListItem.vue中的事件传入到Home.vue中?
    - 因为涉及到非父子组件的通信, 所以这里我们选择了**事件总线**
    - bus -> 总线
    - Vue.prototype.$bus = new Vue()
    - this.$bus.$emit('事件名称', 参数)
    - this.$bus.$on('事件名称', 回调函数(参数))
  + #### Vue -- 事件总线 EventBus
    - EventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为组件传递数据的桥梁的，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的灾难，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。
    - 官方推荐的状态管理方案是 Vuex。不过如果项目不是很大，状态管理也没有很复杂的话，使用 Vuex 没必要。
    - 初始化
      - 第一种方式: 可以在 main.js中，初始化 EventBus
      ```
      Vue.prototype.$EventBus = new Vue()
      ```
      - 第二种方式: 创建一个 Bus.js,再创建事件总线并将其导出，以便其它模块可以使用或者监听它
      ```
      // Bus.js
      import Vue from 'vue'
      export const EventBus = new Vue();
      ```
      - 现在我们已经创建了 EventBus ，接下来你需要做到的就是在你的组件中加载它，并且调用同一个方法，就如你在父子组件中互相传递消息一样。
    - 发送和接受事件
      - 其实和父子组件的通信差不多,用 EventBus.$emit('emit事件名'，数据) 发送，EventBus.$on("emit事件名", callback(payload1,…)) 接受
      ```
      <!-- A.vue -->
      <template>
          <p>{{msgB}}</p>
          <button @click="sendMsgA()">-</button>
      </template>

      <script> 
      import { EventBus } from "../Bus.js";
      export default {
          data(){
              return {
              msg: ''
              }
          },
          mounted() {
              EventBus.$on("bMsg", (msg) => {
                  // a组件接受 b发送来的消息
                  this.msg = msg;
              });
          },
          methods: {
              sendMsgA() {
                  EventBus.$emit("aMsg", '来自A页面的消息'); // a 发送数据
              }
          }
      }; 
      </script>

      <!-- B.vue -->
      <template>
        <p>{{msgA}}</p>
          <button @click="sendMsgB()">-</button>
      </template>

      <script> 
      import { EventBus } from "../event-bus.js";
      export default {
          data(){
              return {
              msg: ''
              }
          },
          mounted() {
              EventBus.$on("aMsg", (msg) => {
                  // b组件接受 a发送来的消息
                  this.msg = msg;
              });
          },
          methods: {
              sendMsgB() {
                  EventBus.$emit("bMsg", '来自b页面的消息'); // b发送数据
              }
          }
      };
      </script>
      ```
      - 如果只监听(接受)一次数据可以使用 EventBus.$once('事件名', callback(payload1,…)
    - 移除事件监听者
      - EventBus.$off('事件名', 回调函数)：
        - EventBus.$off('事件名', callback)，只移除这个回调的监听器
        - EventBus.$off('事件名')，移除该事件所有的监听器
        - EventBus.$off()， 移除所有的事件监听器，注意不需要添加任何参数
        ```
        // 导入我们刚刚创建的 EventBus
        import { EventBus } from '../Bus.js'

        // 事件监听函数
        const clickHandler = function(clickCount) {
          console.log(`Oh, hello)`)
        }

        // 开始监听事件
        EventBus.$on('i-got-clicked', clickHandler);

        // 停止监听
        EventBus.$off('i-got-clicked', clickHandler);
        ```
    - 全局EventBus
      - 全局EventBus，虽然在某些示例中不提倡使用，但它是一种非常漂亮且简单的方法，可以跨组件之间共享数据。它的工作原理是发布/订阅方法，通常称为 Pub/Sub。由于是全局的，必然所有事件都订阅它, 所有组件也发布到它，订阅组件获得更新。也就是说所有组件都能够将事件发布到总线，然后总线由另一个组件订阅，然后订阅它的组件将得到更新。
    - 创建全局EventBus
      - 全局事件总线只不过是一个简单的vue组件
      ```
      var EventBus = new Vue();
      Object.defineProperties(Vue.prototype, {
        $bus: {
          get: function () {
            return EventBus
          }
        }
      })
      // 这个初始化的第一种方法，个人感觉区别不大
      ```
    - 使用 $on 和 $emit
      - 在这个特定的总线中使用两个方法。一个用于创建发出的事件，它就是$emit；另一个用于订阅$on：
      ```
      this.$bus.$emit('nameOfEvent',{ ... pass some event data ...});
      this.$bus.$on('nameOfEvent',($event) => {
          // ...
      })
      ```
    - EventBus 的优缺点
      - 缺点：
        - 大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。
        - 如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。通常会用到，在vue页面销毁时，同时移除EventBus事件监听。
        - 由于是都使用一个Vue实例，所以容易出现重复触发的情景，两个页面都定义了同一个事件名，并且没有用$off销毁（常出现在路由切换时）。
      - 优点:
        - 解决了多层组件之间繁琐的事件传播。
        - 使用原理十分简单，代码量少。
  + 问题一：refresh找不到的问题?
    - 第一: 在Scroll.vue中, 调用this.scroll的方法之前, 判断this.scroll对象是否有值
      ```
      methods: {
        scrollTo(x, y, time = 300) {
          this.scroll && this.scroll.scrollTo(x, y, time);
        },

        finishPullUp() {
          this.scroll.finishPullUp();
        },

        refresh() {
          this.scroll && this.scroll.refresh();
        }
      },
      ```
    - 第二: 在Home组件中的mounted生命周期函数中使用 this.$refs.bscroll而不是在created中
      ```
      mounted() {
        // 3.监听item中图片加载完成
        this.$bus.$on("itemImageLoad", () => {
          // console.log("***");
          this.$refs.bscroll.refresh();
        });
      },
      ```
  + 问题二：对于refresh非常频繁的问题，进行防抖操作
    - 防抖：debounce 
    - 节流：throttle
    - 防抖函数起作用的过程：
      - 如果我们直接执行refresh, 那么refresh函数会被执行30次。
      - 可以将refresh函数传入到debounce函数中, 生成一个新的函数，之后在调用非常频繁的时候，就使用新生成的函数
      - 而新生成的函数，并不会非常频繁的调用，如果下一次执行来的非常快，那么将上一次取消掉
      ```
      debounce(func, delay) {
        let timer = null
        return function (...args) {
          if (timer) clearTimeout(timer)
          timer = setTimeout(() => {
            func.apply(this, args)
          }, delay)
        }
      },
      ```
  + 对于防抖动这种功能函数来说，一般都不会直接封装在某个特定的组件中，所以需要将之前写在组件中的防抖函数抽出来。这里选择在common文件夹中新建文件utils.js，用来存放全局的功能函数，之后在将其export出来，以便能够被其它地方调用。
  ```
  export function debounce(func, delay) {
    let timer = null;
    return function (...args) {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => {
        func.apply(this, args);
      }, delay);
    };
  }
  ```
  + 然后在Home组件中导入方法：import {debounce} from "common/utils";
  + 接着在下方调用debounce方法时就不再是通过this.debounce的方式获取了，而是直接调用debounce方法

### 15.tabControl的吸顶效果
  + 由于之前采用原生scroll来实现滚动时是通过给(.home-tab-control)设置了两个css属性来使它能够实现吸顶效果(position: sticky; top: 44px;)，这里采用better-scroll之后，之前的样式已经不再生效了，所以将其删除掉
  + tabControl的offsetTop获取分析：
    - 要想实现吸顶效果，就必须知道滚动到多少时，开始有吸顶效果
    - 所以需要用一个变量来保存滚动多少的值，这里在Home组件的data属性中添加一个变量tabOffsetTop，接下来就是需要将tabControl组件的滚动量赋值给变量tabOffsetTop就行了，为此给tabControl组件添加一个ref属性，方便在后面能够获取到该组件（不要采用document.querySelector的方法，因为容易找错）
    ```
    <tab-control
      class="home-tab-control"
      :titles="['流行', '新款', '精选']"
      @tabItemClick="tabClick"
      ref="homeTabControl2"
    ></tab-control>
    ```
    - 但是，如果直接在mounted中获取tabControl的offsetTop的值是不正确的，那么如何获取正确的值呢？
      - 监听HomeSwiper中img的加载完成，当图片加载完成之后通过自定义事件给Home组件发送一个信号，告诉Home这边已经加载完成了，这样在Home组件中获取到的offsetTop的值才是正确的（当然了，这里只监听HomeSwiper组件中的图片加载是因为只有该组件的图片影响较大，其余两个组件HomeFeatureView和HomeRecommendView对offsetTop值得计算影响不大）
      - 补充：为了不让HomeSwiper多次发出事件，可以使用isImageLoad变量进行状态的记录
      ```
      <template>
        <swiper>
          <swiper-item v-for="item in banners">
            <a :href="item.link">
              <img :src="item.image" alt="" @load="imageLoad" />
            </a>
          </swiper-item>
        </swiper>
      </template>

      data() {
        return {
          isImageLoad: false,
        };
      },
      methods: {
        imageLoad() {
          if (!this.isImageLoad) {
            this.$emit("swiperImageLoad");
            this.isImageLoad = true;
          }
        },
      },
      ```
    - 接下来在Home中给home-swiper组件添加监听自定义事件：@swiperImageLoad="swiperImageLoad"
    - 在methods方法中实现offsetTop值得获取
    ```
    swiperImageLoad() {
      // 获取homeTabControl2的offsetTop
      // 直接获取组件的offsetTop属性是获取不到的（this.$refs.homeTabControl2.offsetTop）
      // 所有的组件都有一个属性$el：用于获取组件中的元素
      this.tabOffsetTop = this.$refs.homeTabControl2.$el.offsetTop;
    },
    ```
  + 监听滚动，动态改变tabControl的样式
    - 按照正常逻辑，此时我们需要给tabControl设置一个样式，让它能够在滚动到一定位置（即当isTabControlFixed为true的时候）后可以固定在上方不随着一起滚动，所以给它设置一个动态样式，动态绑定class属性。
    ```
    <tab-control
        :class="{fixed: isTabControlFixed}"
        :titles="['流行', '新款', '精选']"
        @tabItemClick="tabClick"
        ref="homeTabControl2"
    ></tab-control>

    .fixed {
      position: fixed;
      top: 44px;
      left: 0;
      right: 0;
    }
    ```
    - 但是如果按照上面这样实现的话，就会发现，当我们滚动到isTabControlFixed变为true时，会发现tabControl组件仍然没有按照我们的想法固定在离顶部44px处的位置，这是为什么呢？
      - 这是因为better-scroll组件内部实现的原因造成的，当我们在使用better-scroll进行滚动时，改变的是better-scroll组件强加给tabControl组件的 transform：translate(0px, -600px) 这个属性，而这个属性会对我们设置的fixed属性产生影响，即便设置了 position：fixed，但是此时tabControl仍然会随着better-scroll的滚动而向上方滚动，所以才会出现看不见的情况。
    - 而且在我们滚动过tabControl组件的范围之后，在即将滚动到第一张图片时，会发现滚动会出现一个跳跃现象，不再是平滑的过渡到第一张图片，这是为什么呢？
      - 这是因为原来fixed属性没有生效时，在整个布局上，图片的上方是有一个tabControl组件的存在，图片的位置布局是基于tabControl来定位的，现在一旦fixed属性生效后，那么tabControl就相当于脱离了这个整体布局，图片上方就空了一片距离出来，所以说此时图片就会出现跳跃式的向上偏移一下，这样是非常不合理的。
    - 为了能够给用户实现一个友好的滚动方式，可以采取以下措施：
      - 将之前给<tab-control>组件添加的fixed样式全部删除掉
      - 将<tab-control>这个组件整体复制，在<scroll>组件的外面在写一个<tab-control>组件，给外面的这个<tab-control>组件添加样式（.home-tab-control{ position: relative; z-index: 9;}），由于是放置在导航栏的下方，所以设置一个相对定位即可，再将它的层级设置一下
      - 接着我们向下滚动会发现，当我们滚动过<scroll>组件的中的<tab-control>组件时，虽然此时里面这个<tab-control>组件仍然不可见，但是外部的这个是完美的固定在了上方，继续向下滚动也不会发生偏移，符合我们的预期效果
      - 最后我们只需要实现一个步骤即可，即在最开始页面一加载时，将外部的<tab-control>组件用 v-show 属性设置为隐藏（false），当滚动到合适的位置时再将 v-show 的属性设置为显示（true）就行了，这样就能动态的决定<tab-control>组件的显示了
      ```
      <template>
        <div id="home" class="wrapper">
          <nav-bar class="home-nav"><div slot="middle">购物街</div></nav-bar>
          <tab-control
            class="home-tab-control"
            :titles="['流行', '新款', '精选']"
            @tabItemClick="tabClick"
            ref="homeTabControl"
            v-show="isTabControlFixed"
          ></tab-control>

          <scroll
            class="scroll"
            ref="bscroll"
            :probe-type="3"
            :pull-up-load="true"
            @scroll="contentScroll"
            @pullingUp="loadMore"
          >
            <home-swiper
              :banners="banners"
              @swiperImageLoad="swiperImageLoad"
            ></home-swiper>
            <home-recommend-view :recommends="recommends"></home-recommend-view>
            <home-feature-view></home-feature-view>

            <tab-control
              :titles="['流行', '新款', '精选']"
              @tabItemClick="tabClick"
              ref="homeTabControl"
            ></tab-control>

            <goods-list :goods="showGoods"></goods-list>
          </scroll>

          <back-top @click.native="backClick" v-show="isShowBackTop"></back-top>
        </div>
      </template>
      ```
    - 最后还会有一个小问题，就是在当我们切换到新款或者精选页面向下滚动时，会出现tabControl组件的标签仍然是流行标签为选中的情况，不是我们选中的那个页面的标签为选中状态，这个问题该怎样解决？
      - 因为在TabControl组件中，有一个currentIndex属性是用来判断当前是哪个标签页面被选中的，而现在由于我们又增加了一个TabControl组件，它们两个组件之间的状态并没有做到统一，所以才会出现上面所说的那种现象
      - 这里只需要简单的两步就可以实现状态的统一，由于之前已经给两个<tab-control>组件设置了一个ref属性（ref="homeTabControl"）,但是我们没有办法做到区分，所以这里稍作修改，将其分别命名为homeTabControl1和homeTabControl2，然后在事件监听的方法tabClick中给他们两个的组件的currentIndex属性赋值即可
      ```
      methods: {
        tabClick(index) {
          switch (index) {
            case 0:
              this.currentType = "pop";
              break;
            case 1:
              this.currentType = "new";
              break;
            case 2:
              this.currentType = "sell";
              break;
            default:
              break;
          }
          this.$refs.homeTabControl1.currentIndex = index;
          this.$refs.homeTabControl2.currentIndex = index;
        },
      }
      ```
  + 此时tabControl的吸顶效果就完成了

### 16.Home离开时记录状态和位置
  + 如何让Home在离开时不要销毁掉，仍然保留呢？
    - 很简单，使用<keep-alive>即可，在App.vue中，给<router-view>外面添加一层<keep-alive>
    - 这样就可以保证在离开Home页面时，不会被销毁，这样避免了频繁的创建带来的性能问题，同时理论上来说，页面没有被销毁，那么意味着页面还会停留在离开时的位置，当再次回到该页面时，仍然是之前的位置和状态。但是，由于better-scroll插件的影响，有时候会出现页面虽然没有被销毁，但是却没有保留之前离开时的位置和状态
  + 如何让Home中的内容继续保持离开时的状态呢？
    - 离开时, 保存一个位置信息saveY.
    ```
    deactivated() {
      this.saveY = this.$refs.bscroll.getScrollY();
    },
    ```
    - 进来时, 将位置设置为原来保存的位置saveY信息即可.
    ```
    activated() {
      this.$refs.bscroll.scrollTo(0, this.saveY, 0);
      this.$refs.bscroll.refresh();
    },
    ```
    - 注意: 最好回来时, 进行一次refresh()

### 17.跳转到详情页并携带id,同时初始化详情页导航栏
  + 这里要实现跳转到详情页面，可以通过路由的而方式实现
  + 在views文件夹中创建详情页文件夹detail，并在里面创建Detail.vue组件
  + 在路由配置文件中添加detail的配置
  ```
  const Detail = () => import('views/detail/Detail')
  const routes = [
    {
      path: '/detail/:iid',
      component: Detail
    }
  ]
  ```
  + 到此准备工作已经完成了，当我们想要实现点击商品跳转到详情页面，那么我们就应该直接到商品展示的那个组件中来实现路由跳转，所以这里在GoodsListItem组件中添加一个点击监听事件，并在该事件的方法中实现路由的跳转，这里路由跳转选择使用push的方法而不使用replace的方法是因为，我们待会还会从详情页回到跳转前的页面，用push的话就可以很方便的调用它的返回函数接口back。
  ```
  <template>
    <div class="goods-item" @click="itemClick">
      <img :src="goodsItem.show.img" alt="" @load="imageLoad" />
      <div class="goods-info">
        <p>{{ goodsItem.title }}</p>
        <span class="price">{{ goodsItem.price }}</span>
        <span class="collect">{{ goodsItem.cfav }}</span>
      </div>
    </div>
  </template>

  methods: {
    itemClick() {
      this.$router.push("/detail/" + this.goodsItem.iid);
    },
  }
  ```
  + 这里由于要将这个商品的id传递给详情页，所以采用动态路由的方式来进行字符串的拼接。至此，已经能够实现点击商品跳转到详情页，并将该商品的id传递过去。
  + 实现详情页的导航栏的实现：
    - 由于该导航栏与首页的导航栏不一样，所以我们不能单纯的直接将之前封装好的NavBar组件拿过来使用，这里我们考虑到如果直接在Detail组件中来实现导航栏的话，会造成代码的复杂，不利于后期维护，所以选择在detail文件夹下创建子文件夹childComponents，在里面创建详情页的子组件DetailNavBar，在这个子组件中导入外面封装好的导航栏组件NavBar，并给里面对应插槽添加对应的内容
    ```
    <template>
      <div>
        <nav-bar>
          <div slot="left" class="back" @click="backClick"> 
            <img src="~assets/img/common/back.svg" alt="">
          </div>
          <div slot="middle" class="title">
            <div
              v-for="(item, index) in titles"
              class="title-item"
              :class="{ active: index === currentIndex }"
              @click="titleClick(index)"
            >
              {{ item }}
            </div>
          </div>
        </nav-bar>
      </div>
    </template>

    <script>
    import NavBar from "components/common/navbar/NavBar";

    export default {
      name: "DetailNavBar",
      data() {
        return {
          titles: ["商品", "参数", "评论", "推荐"],
          currentIndex: 0,
        };
      },
      components: {
        NavBar,
      },
      methods: {
        titleClick(index) {
          this.currentIndex = index;
        },
        backClick() {
          this.$router.back();
        }
      },
    };
    </script>

    <style scoped>
    .title {
      display: flex;
      font-size: 13px;
    }

    .title-item {
      flex: 1;
    }

    .active {
      color: var(--color-high-text);
    }

    .back img {
      margin-top: 12px;
    }
    </style>
    ```
    - 首先我们先左侧插槽插入对应的图片标签，并设置它的样式，添加一个监听事件backClick，当被触发时会跳转回到之前的页面；接着设置中间部分的插槽，因为我们可以明确的知道插槽部分的文字内容是不会改变的，所以可以直接在本地写死，这里用一个数组来存放这些文字标签，接着就使用v-for遍历数组，来动态创建标签，创建完毕后会发现它默认是竖直排列的，给它设置样式，让它能水平均匀分布；接下来就要实现点击那个标签，那个标签就变色的步骤了，因为需要知道具体点击的是哪个标签，所以在遍历时加上一个index属性，然后动态绑定一个class属性active，判断条件是当前遍历时的index和点击时的currentIndex值相等，那么active就处于活跃状态，颜色就会变化；在然后就是监听点击事件了，当点击方法titleClick被触发时，会将当前传入的index赋值给currentIndex；


### 18.详情页数据请求以及轮播图的展示
  + 获取详情页数据，这里在知道了商品的iid之后，通过在网络请求文件夹中封装一个Detail.js文件来作为详情页的数据请求接口
  ```
  import { request } from './request'
  export function getDetail(iid) {
    return request({
      url: '/detail',
      params: {
        iid
      }
    })
  }
  ```
  + 首先需要获取的是轮播图的数据，在Detail组件中导入getDetail方法并调用。因为这里需要展示一个轮播图，所以说可以单独封装一个详情页的轮播图组件DetailSwiper.vue，写法与首页的轮播图组件类似，都需要父组件给它传递参数，通过遍历的方式来动态添加轮播图的图片
  ```
  <template>
    <div id="detail">
      <detail-nav-bar></detail-nav-bar>
      <detail-swiper :top-images="topImages"></detail-swiper>
    </div>
  </template>

  created() {
    // 1.保存传入的商品iid
    this.iid = this.$route.params.iid;

    // 2.根据对应的iid请求对应的详情数据
    getDetail(this.iid).then((res) => {
      // 2.1 先获取顶部轮播图数据
      this.topImages = res.result.itemInfo.topImages;
    });
  },
  ```
  + 由于图片都非常大，所以可以采取设置轮播图的高度来限制图片的大小
  ```
  <template>
    <swiper class="detail-swiper">
      <swiper-item v-for="item in topImages">
        <img :src="item" alt="" />
      </swiper-item>
    </swiper>
  </template>

  <script>
  import { Swiper, SwiperItem } from "components/common/swiper";
  export default {
    name: "DetailSwiper",
    props: {
      topImages: {
        type: Array,
        default() {
          return [];
        },
      },
    },
    components: {
      Swiper,
      SwiperItem,
    },
  };
  </script>

  <style scoped>
  .detail-swiper {
    height: 300px;
    overflow: hidden;
  }
  </style>
  ```

### 19.商品基本信息的展示
  + 由于商品详情页的数据非常多，如果我们直接一个模块一个模块的去取的话，会非常麻烦，而且也极容易出错，后期也不易于维护。因此，采用面向对象的封装思想，先提前建立一个类，这个类中的成员变量就是我们需要从服务器返回的数据中取出的我们需要的值，这样在后面使用时只需要new一个该类，并传入对应的值就可以直接获取到了，不需要在专门一一的去建立对应的变量用来保存这些数据。所以在网络请求模块中封装以下几个类
  ```
  export class Goods {
    constructor(itemInfo, columns, services) {
      this.title = itemInfo.title
      this.desc = itemInfo.desc
      this.newPrice = itemInfo.price
      this.oldPrice = itemInfo.oldPrice
      this.discount = itemInfo.discountDesc
      this.columns = columns
      this.services = services
      this.realPrice = itemInfo.lowNowPrice
    }
  }
  export class Shop {
    constructor(shopInfo) {
      this.logo = shopInfo.shopLogo;
      this.name = shopInfo.name;
      this.fans = shopInfo.cFans;
      this.sells = shopInfo.cSells;
      this.score = shopInfo.score;
      this.goodsCount = shopInfo.cGoods
    }
  }
  export class GoodsParam {
    constructor(info, rule) {
      // 注: images可能没有值(某些商品有值, 某些没有值)
      this.image = info.images ? info.images[0] : '';
      this.infos = info.set;
      this.sizes = rule.tables;
    }
  }
  ```
  + 在Detail组件中调用前面封装好的类，这样获取到的数据里面就只会包含我们想要的数据，就不再像是返回的整个res里面的那些多且复杂的数据
  ```
  <template>
    <div id="detail">
      <detail-nav-bar></detail-nav-bar>
      <detail-swiper :top-images="topImages"></detail-swiper>
      <detail-base-info :goods="goods"></detail-base-info>
    </div>
  </template>

  import { getDetail, Goods } from "network/detail";

  export default {
    name: "Detail",
    data() {
      return {
        iid: null,
        topImages: [],
        goods: {},
      };
    },
    components: {
      DetailNavBar,
      DetailSwiper,
    },
    created() {
      // 1.保存传入的商品iid
      this.iid = this.$route.params.iid;

      // 2.根据对应的iid请求对应的详情数据
      getDetail(this.iid).then((res) => {
        const data = res.result;
        // 2.1 先获取顶部轮播图数据
        this.topImages = data.itemInfo.topImages;

        // 2.2 获取商品信息
        this.goods = new Goods(data.itemInfo, data.columns, data.shopInfo.services)
      });
    },
  };
  ```
  + 新建DetailBaseInfo组件，该组件主要包含了四个部分，第一部分是商品的title，第二部分是商品的价格，第三部分是商品的销量、收藏数量等，第四部分是商品的一些保证信息（比如全国包邮，7天无理由退货，退货补运费等等）。
  ```
  <template>
    <div v-if="Object.keys(goods).length !== 0" class="base-info">
      <div class="info-title">{{ goods.title }}</div>
      <div class="info-price">
        <span class="n-price">{{ goods.newPrice }}</span>
        <span class="o-price">{{ goods.oldPrice }}</span>
        <span v-if="goods.discount" class="discount">{{ goods.discount }}</span>
      </div>
      <div class="info-other">
        <span>{{ goods.columns[0] }}</span>
        <span>{{ goods.columns[1] }}</span>
        <span>{{ goods.services[goods.services.length - 1].name }}</span>
      </div>

      <!-- 此处遍历的是数字，而不是数组成员；从1开始遍历，直到遍历限制的最大值 -->
      <div class="info-service">
        <span
          class="info-service-item"
          v-for="index in goods.services.length - 1"
          :key="index"
        >
          <img :src="goods.services[index - 1].icon" />
          <span>{{ goods.services[index - 1].name }}</span>
        </span>
      </div>
    </div>
  </template>
  ```
  + 同时也考虑到了，有时候点进一个商品时，不一定会有信息的存在，所以在最外层的div加了一层判断，即只有当goods里面有商品信息时才会按照给定的布局样式加载，如果没有信息，则不会加载。
  + 前面三个部分的加载相对来说比较简单，只需要找到对应的值，将其赋上去就行了；对于第四部分的加载，这里采用循环遍历的方式来动态生成span标签，并且这里遍历时不是遍历goods.services数组里的成员，而是遍历的数字，从1开始遍历，直到遍历的数组的最大值，而且因为之前已经从数组中取出了一个成员，所以在这里遍历时数组的长度就应该减掉1才行

### 20.店铺信息的解析与展示
  + 创建DetailShopInfo.vue组件，用来显示店铺相关的信息
  + 由最终的呈现效果图可以知道，店铺信息主要可水平划分为三个部分，顶部是店铺的logo和店铺名称；中间部分又可以划分为左右两个部分，左边部分是商品的销量以及店铺的全部宝贝数量，右边部分是商品以及店铺的满意度评分；底部是一个跳转按钮，点击它之后可以进到店铺的详情页里面。
  + 顶部布局解析：左边是一个存放logo图片的img标签，在img标签右侧是一个显示店铺名称的文本标签span，这里只需要将这个span标签设置成距离左侧img标签一定距离即可（margin-left:10px）并设置span标签行内元素的垂直对齐方式
  + 中间部分布局解析：
    - 左侧部分布局解析：左侧可划分为两个部分，一部分是总销量，一部分是全部宝贝数量
      - 总销量部分布局解析：该部分由两部分组成，一个是动态的总销量数的数值，一个是写死的文字“总销量”；对于销量数值来说，这个数字是不规律的，需要进行计算拼接才能达到我们想要的效果，比如说，当数值小于10000时，可以直接将该数值赋值到文本中，一旦数值大于10000，达到了好几万的时候，再这么直接写到上面，难免会出现文本的长度超出我们所设置的最大宽度的界限，因此，可以选择将其进行就算，取除以10000后的值，并保留一位小数，最后在给它拼接一个单位“万”，这样就可以完美呈现了。
      - 全部宝贝数量部分布局解析：该部分也是由两个部分组成，一个是动态的额全部宝贝数量，一个是写死的文字“全部宝贝”；考虑到一家店铺的全部宝贝数量一般不会过万，所以就直接采取赋值，不再计算
    - 右侧部分布局解析：
      - 从效果图上来看，这里可以由三行div或者span组成。也就是说如果用div或span来实现的话，这里就会被划分为三个部分，而且实现起来过于繁琐；但是还有其它的选择，这里选择采用表格的形式来实现，通过遍历shop.score数组，动态的生成三行表格，每行表格里面又包含了三列。由数据可以得知，数据中是没有直接写明评分是低还是高这个选型的，它只给出了一个isBetter这个选项，当它为true时，评分为高，而且字体颜色为红色，当它为false时，评分为低，而且字体颜色为绿色；所以可以通过三目运算符来判断到底是高还是低，至于颜色就只有通过设置样式来设置了，为false，就不给该列绑定class属性，为true时就绑定一个class属性
  + 底部布局解析：底部只有一个超链接标签，当点击该标签时会跳转到该店铺的首页中（此处没有实现）

### 21.详情页加入better-scroll滚动效果
  + 滚动时可以发现，详情页最下方的MainTabBar组件也会一直存在，按理说跳转到详情页之后，这个MainTabBar组件应该被隐藏掉的，所以这里需要给Detail组件加上几个设置将其隐藏。
  ```
  #detail {
    position: relative;
    z-index: 9;
    background-color: #fff;
  }
  ```
  + 导入之前封装好的better-scroll组件，为了实现滚动，需要给他的父组件设置一个高度，这里给detail设置高度为100vh，然后就是设置scroll组件的可滚动区域了，这里设置成离顶部44px的位置，即除了detail-nav-bar以下的部分都可以滚动。

### 22.商品详情信息的展示
  + 创建DetailGoodsInfo.vue组件用来展示商品的详细信息
  + 该部分大致可划分为三个模块，分别是info-desc、info-key、info-list
  + 这里主要解析下info-list部分，这里面是由很多张图片组成的，所以采用遍历的方式，动态添加img标签，并且由于需要避免出现滚动卡顿的现象，这里需要监听一个图片加载完成的事件，但是这里的加载完成就不再单单指一张图片加载完成了，而是指所有的图片加载完成，所以这里可以设置一个计数器，当计数器的计数值等于源数据的数组长度时，再去调用自定义事件datailImageLoad。
  + 如何获取源数据的数组长度呢？
    - 这里采用watch方法，它的作用是监听某个属性的变化，因为我们在初始化时给dateilInfo赋的值为空，所以第一时间传过来的值会是0，然后当我们将从服务器请求的数据赋值给变量dateilInfo之后，他的list的长度就会发生变化，此时imagesLength的大小就等于图片的个数了。
    - 其实本可以不用这么复杂的，直接在imageLoad方法中进行判断，即如下方所示，但是这么写的话，就会造成这边在不断的请求list的长度，这样会比较消耗性能，尤其是当它的详情页图片特别多的时候，可能会出现卡顿的现象
    ```
    this.counter += 1;
    if (this.counter === this.detailInfo.detailImage[0].list.length) {
      this.$emit("detailImageLoad");
    }
    ```
  
### 23.商品参数信息的展示，例如：尺码、生产信息等
  + 创建DetailParamInfo.vue组件用来展示商品的参数信息
  + 该部分也大致可划分为三个模块，分别是info-size、info-param、info-image
  + info-size主要是展示的尺码信息，这里是通过table来展示，有多个表就展示多个表，实现起来也比较简单，首先在最外层遍历表的数量，然后就得到了该表的内容，接着就遍历该表的行数，就得到了一行的内容，最后再遍历一行的内容，就得到了多列的内容
  + info-param主要是展示的商品的成分信息以及生产厂家的信息，也是通过table来进行展示，通过遍历infos的内容，获取到key以及value，将它们赋值到对应的每列中即可
  + info-image主要是展示的参数后面的图片信息，有些商品有，有些商品时没有的，所以在显示时加了个v-if的判断，如果存放图片的变量的长度不为0，那么就展示该图片
  ```
  <template>
    <div class="param-info" v-if="Object.keys(paramInfo).length !== 0">
      <table
        v-for="(table, index) in paramInfo.sizes"
        class="info-size"
        :key="index"
      >
        <tr v-for="(tr, indey) in table" :key="indey">
          <td v-for="(td, indez) in tr" :key="indez">{{ td }}</td>
        </tr>
      </table>

      <table class="info-param">
        <tr v-for="(info, index) in paramInfo.infos">
          <td class="info-param-key">{{ info.key }}</td>
          <td class="param-value">{{ info.value }}</td>
        </tr>
      </table>

      <div class="info-img" v-if="paramInfo.image.length !== 0">
        <img :src="paramInfo.image" alt="" />
      </div>
    </div>
  </template>
  ```

### 24.商品评论信息的展示
  + 创建DetailCommentInfo.vue组件用来展示商品的评论信息
  + 该部分可划分为3个部分，第一部分是最上方的标题栏，包含用户评价标签以及更多的超链接标签；第二部分可分为两块，一块是紧接着的用户信息部分，该部分包含用户头像以及用户名，一块是紧接着用户信息下方的对商品的评价信息以及评价日期；第三部分是用户晒出的评价图片展示。
  + 这里布局样式设置就比较简单了，按照最终的效果图进行调整即可。
  + 这里需要注意的是日期的转换，从数据中取出的日期是转换成毫秒的一个时间戳，这里我们需要将它转换成年月日的形式；封装一个日期转换函数formatDate()，由于这个函数可以是通用的，所以将它封装在common目录下utils.js文件中，这样方便以后其他地方调用。
  + 对于更多的选项，可以选择在更多的标签里面添加一个监听事件，当点击了更多之后，可以跳转到一个页面，该页面用来展示该商品的全部评论信息。
  ```
  <span class="comment_more" @click="loadMoreComment">更多</span>
  ```

### 25.商品推荐信息的展示
  + 由于推荐信息的数据接口和详情页的数据接口不是同一个，所以首先要做的就是封装一个推荐信息的数据请求接口
  + 在detail.js文件中封装一个函数 getRecomment() 用来请求推荐信息，在Detail.vue中导入该方法，由函数的返回值可知，我们想要的内容是res.data.list这个数组中的，所以建立一个数组变量用来保存这些推荐信息
  + 由最终的效果图可知，推荐信息的展示和首页的商品信息的布局样式一样，所以这里可以复用首页的商品组件，不用在单独建立详情页的推荐信息组件。只需要将保存推荐信息的数组变量recommends传递给<goods-list>组件即可
  ```
  <goods-list :goods="recommends"></goods-list>
  ```
  + 在GoodsList组件接收到数据之后，就会将遍历出来的单个商品信息传递给它的子组件GoodsListItem，但是这时我们会发现一个问题，会发现前端报错了，检查错误发现是没有正确获取图片信息导致的，因为detail接口和recommend接口里面获取图片的方式不一致导致的，detail接口是：goodsItem.show.img ；recommend接口是： goodsItem.image；所以这里需要稍作修改，通过一个计算属性来决定到底采用哪种获取方式
  ```
  <img :src="showImage" alt="" @load="imageLoad" />
  computed: {
    showImage() {
      return this.goodsItem.image || this.goodsItem.show.img;
    },
  },
  ```
  + 这样详情页的推荐信息就完成了

### 26.首页和详情页监听全局事件和mixin的使用
  + 由于首页和详情页都调用了GoodsList组件，在GoodsListItem组件中我们添加了全局事件“itemImageLoad”，用来判断图片是否加载完毕，如果这里不做修改的话，那么当我们从首页点进详情页时，就会触发该事件，但是这个事件其实已经在首页加载时就触发过了，我们想要的效果是点进详情页时，不会触发该全局事件，那么该如何解决呢？
    - 方式一：可以在发送事件处添加条件判断，使得首页的监听事件只对来自首页商品信息的加载完成生效，对于详情页的不会生效
    ```
    imageLoad() {
      if(this.$route.path.indexOf('/home')) {
        this.$bus.$emit("homeItemImageLoad");
      } else if(this.$route.path.indexOf('/detail')) {
        this.$bus.$emit("detailItemImageLoad");
      }
    },
    ```
    - 方式二：采用取消全局事件监听的方式，即当离开首页时，取消全局事件监听。
    ```
    deactivated() {
      // 2.取消全局事件的监听
      this.$bus.$off("itemImageLoad", this.itemImageListener);
    },

    mounted() {
      // 1.监听item中图片加载完成（添加防抖函数）
      const refresh = debounce(this.$refs.bscroll.refresh, 100);
      this.itemImageListener = () => {
        refresh();
      };
      this.$bus.$on("itemImageLoad", this.itemImageListener);
    },
    ```
    - 注意：这里在取消时，不能只单单传一个事件名称就行，还需要传一个函数，告诉它到底要取消哪个函数的全局事件监听；如果不传的话，那么默认是将所有的全局事件都取消掉。
  + 对于详情页来说，也是需要进行全局事件监听以及取消的。对于监听来说，写法与首页的一致，都是在mounted中进行监听，只有取消监听的位置不同，对于在keep-alive里的组件来说，activated() 和  deactivated() 钩子是可以生效的，但是对于不在 keep-alive 里的组件来说，这两个钩子函数是不会生效起作用的，所以取消全局事件监听就不能在放在 deactivated() 钩子中了，这里选择将它放在 destroyed() 钩子函数中
  ```
  mounted() {
    // 1.监听item中图片加载完成（添加防抖函数）
    const refresh = debounce(this.$refs.bscroll.refresh, 100);
    this.itemImageListener = () => {
      refresh();
    };
    this.$bus.$on("itemImageLoad", this.itemImageListener);
  },
  destroyed() {
    // 2.取消全局事件的监听
    this.$bus.$off("itemImageLoad", this.itemImageListener);
  },
  ```
  + 对比Home组件与Detail组件可以发现，这两个组件中有很多地方是完全一模一样的，如果在两个组件中存在完全一样的部分，不仅会造成代码的冗余，也会造成不利于阅读维护。所以可以使用 Mixin 来实现对代码的复用，同时也能避免多继承的复杂
    - 即新建一个公共的文件mixin.js，我们将Home和Detail组件中的mounted部分抽取出来，同时也将data中变量itemImageListener抽取出来
    ```
    import { debounce } from "common/utils";

    export const itemListenerMixin = {
      data() {
        return {
          itemImageListener: null,
          newRefresh: null,
        }
      },
      mounted() {
        // const refresh = debounce(this.$refs.bscroll.refresh, 100);
        this.newRefresh = debounce(this.$refs.bscroll.refresh, 100);
        this.itemImageListener = () => {
          // refresh();
          this.newRefresh();
        };
        this.$bus.$on("itemImageLoad", this.itemImageListener);
      },
      // components: {},
      // methods: {},
    }
    ```
    - 接着在各自组件中导入mixin文件中export出来的 itemListenerMixin，然后在export default{}中使用它
    ```
    import { itemListenerMixin } from "common/mixin";
    export default {
      mixins: [itemListenerMixin],
    }
    ```
    - 通过上面这种方式操作之后，vue会自动的将mixin中的代码混入到各自调用它的组件中去，而且像是组件、方法等属性也都是支持混入的。
  + 为了解决详情页不能滚动的BUG，这里需要给DetailGoodsInfo组件中添加一个事件监听，在所有图片加载完毕之后发出，告诉详情页图片已经加载完毕（在Detail组件中监听该事件即可，并在对应的方法中调用刷新函数），可以调用refresh函数刷新better-scroll组件了，这样就可以正确的计算出可滚动区域的高度
  + 这里我们考虑到减少刷新的频率，就选择将之前在mixin.js中封装的刷新函数进行改写。建立一个全局的变量（newRefresh）用来保存这个刷新函数，这样一来，由于混入的存在，所以我们在调用混入的地方也是可以直接拿到混入函数里面的变量的，所以只需要在Detail组件中实现一个方法，在方法中调用this.newRefresh()即可。
  ```
  methods: {
    detailImageLoad() {
      this.newRefresh();
    },
  }
  ```

### 27.详情页点击标题滚动到对应内容(实现联动效果)
#### 27.1 点击标题滚动到对应的内容区域
  + 第一步：在DetailNavBar中监听事件点击，通过自定义事件将点击时的下标传递给父组件Detail，在父组件中监听子组件的自定义事件，并在methods方法中实现滚动。原理是通过设置一个数组变量，里面会保存着四个值，分别对应子组件DetailNavBar中的四个标签。它们的值的获取是通过取该组件离顶部的距离多少来决定的，这里默认商品的距离是0，其余三个则通过给各自对应的组件添加一个ref属性，用来获取该组件离顶部的offsetTop
  + 第二步：正确的取到offsetTop的值。首先考虑到在 created() 中获取肯定不行，压根不能获取元素；在mounted()中也不行，数据还没有获取到；在获取详情页数据的回调中来获取也不行，此时DOM还没有渲染完，通过该方式可以得出，此时获取不到 this.$refs.params.$el ，因为虽然获取值得函数是写在最后面的，但是我们不能保证页面已经渲染完成了；此时又想到了另一种方法，在 this.$nextTick() 的回调函数中来实现，将获取值得函数放到这里面后，确实能够取到值了，不再有undefined的情况了，但是又发现获取到的值不正确，这里因为虽然DOM已经渲染完了，但是里面的图片不一定已经渲染完毕，所以会导致取到的offsetTop的值会偏小，那么应该如何正确的取到值呢？
    - 答案是将获取offsetTop值得函数移动到之前的监听事件方法中(详情页图片加载完毕的函数接口中去)实现，这样就可以保证详情页中的DOM和图片都已经完全渲染完毕，此时获取的值就是正确的。
    - 为了减少频繁的获取，所以要添加一个防抖函数，这里可以采用之前的写法，用一个变量来保存防抖函数return出来的这个函数方法，这里就可以选择将这个防抖函数的调用放到 created() 钩子中实现，然后只需要在使用的地方调用这个函数变量即可。
    ```
    created()  {
      // 4.给this.getThemeTopY赋值(对给this.themeTopY赋值的操作进行防抖)
      this.getThemeTopY = debounce(() => {
        this.themeTopY = [];
        this.themeTopY.push(0);
        this.themeTopY.push(this.$refs.params.$el.offsetTop);
        this.themeTopY.push(this.$refs.comment.$el.offsetTop);
        this.themeTopY.push(this.$refs.recommend.$el.offsetTop);
      });
    },
    methods: {
      detailImageLoad() {
        this.newRefresh();
        this.getThemeTopY();
      },
      titleClick(index) {
        this.$refs.bscroll.scrollTo(0, -this.themeTopY[index], 300);
      },
    },  
    ```
#### 27.2 滚动内容到对应区域时，标题发送改变
  + 为了实现这个功能，需要知道已经滚动到的位置，因为在scroll组件中已经建立过一个自定义事件，该事件会发出滚动的位置，所以在Detail组件中只需要监听该事件即可，并且为了能够监听滚动，这里需要给Scroll组件传递一个参数 probeType=3，只有这样才能监听滚动事件
  + 实现原理也很简单，只需要判断一下当前滚动的位置与之前获取到的各组件距离顶部的距离进行一个比较，就能得出当前的位置，然后将当前所属的位置下标发给Detail组件的子组件DetailNavBar，就可以实现了
  ```
  contentScroll(position) {
    // 1.获取Y值
    const positionY = -position.y;

    // 2.positionY和各组件距离顶部的值进行比较
    // positionY 在 0 和 this.$refs.params.$el.offsetTop 之间，则令 index=0
    // positionY 在大于等于 this.$refs.params.$el.offsetTop 和 this.$refs.comment.$el.offsetTop 之间，则令 index=1
    // positionY 在大于等于 this.$refs.comment.$el.offsetTop 和 this.$refs.recommend.$el.offsetTop 之间，则令 index=2
    // positionY 大于等于 this.$refs.recommend.$el.offsetTop ，则令 index=3
    let length = this.themeTopY.length;
    for (let i = 0; i < length; i++) {
      if (
        (this.currentIndex !== i) &&
        ((i < length - 1 &&
          positionY >= this.themeTopY[i] &&
          positionY < this.themeTopY[i + 1]) ||
          (i === length - 1 && positionY >= this.themeTopY[i]))
      ) {
        this.currentIndex = i;
        console.log(this.currentIndex);
        this.$refs.detailNavBar.currentIndex = this.currentIndex;
      }
    }
  },
  ```
  + 鉴于之前的条件判断过于复杂，这里可以采用另一种方式来实现，给数组themeTopY中添加一个假的最大值，这样一来判断条件就可以做到一致了，就可以将判断条件省去一部分
  ```
  this.getThemeTopY = debounce(() => {
    this.themeTopY = [];
    this.themeTopY.push(0);
    this.themeTopY.push(this.$refs.params.$el.offsetTop);
    this.themeTopY.push(this.$refs.comment.$el.offsetTop);
    this.themeTopY.push(this.$refs.recommend.$el.offsetTop);

    this.themeTopY.push(Number.MAX_VALUE);
  });

  contentScroll(position) {
    const positionY = -position.y;
    let length = this.themeTopY.length;
    // hack做法（条件简化方法）：给themeTopY数组中添加一个假的最大值，这样就可以大大优化判断逻辑
    // 虽然这样会多占据一些内存，但是这样可以优化代码的执行速度（用空间换时间）
    for (let i = 0; i < length - 1; i++) {
      if (
        this.currentIndex !== i &&
        positionY >= this.themeTopY[i] &&
        positionY < this.themeTopY[i + 1]
      ) {
        this.currentIndex = i;
        this.$refs.detailNavBar.currentIndex = this.currentIndex;
      }
    }
  },
  ```

### 28.详情页底部工具栏的封装
  + 创建DetailBottomBar.vue组件用来显示详情页底部的工具栏
  + 这个工具栏的样式只需要按照最终的效果图进行布局，比较简单，这里主要分为左右两块

### 29.详情页BackTop按钮的混入封装
  + 由于详情页和首页均有backTop按钮，这里就可以考虑使用混入，这样不仅可以减少代码，而且利于维护
  + 在mixin.js中封装一个对象，backTopMixin，这里可以将两个地方都会使用到的东西拿进来进行一个封装。将BackTop组件也一并封装进来，这样在其他组件想要使用这个backTop按钮时，就不需要在导入BackTop组件了，只需要将mixin.js中的backTopMixin导入即可，这样能省去不少事
  ```
  export const backTopMixin = {
    components: {
      BackTop
    },
    data() {
      return {
        isShowBackTop: false,
      }
    },
    methods: {
      backClick() {
        // 可以通过this.$refs.bscroll直接访问到scroll组件中的属性以及方法
        this.$refs.bscroll.scrollTo(0, 0, 300);
      },
      listenIsShowBackTop(position) {
        this.isShowBackTop = -position.y > BACK_POSITION;
      },
    }
  }
  ```
  + #### 注意：对于混入来说，生命周期函数以及方法都是可以混入的，但是对于方法来说，混入只支持混入到方法中的函数这一层，对于函数内部的东西是不支持混入的
  + 通过将BackTop混入封装之后，在Home和Detail组件中调用时就只需要导入mixin.js中export出来的即可，然后在export default {}中注册使用即可，最后在滚动的事件监听函数中调用监听backTop按钮是否显示的函数接口即可。
  ```
  import { itemListenerMixin, backTopMixin } from "common/mixin";
  export default {
    mixins: [itemListenerMixin, backTopMixin],
    methods: {
      contentScroll(position) {
        this.listenIsShowBackTop(position);
      }
    }
  }
  ```

### 30.将商品添加到购物车中
  + 为了实现将商品添加到购物车中，这里需要给加入购物车这个按钮添加一个监听事件，在点击了它之后，会在这个事件方法(addToCart())中发出一个自定义的事件(addCart)，告诉Detail组件这个商品需要被添加到购物车中，然后让Detail组件来实现将商品添加到购物车里面
  + 在Deatil组件中监听addCart自定义事件，然后在addToCart方法中实现；首先获取我们需要在购物车界面中展示的信息，这里可以用一个对象来表示，接着就可以将商品添加到购物车中了，这里使用Vuex来进行购物车的状态管理
  + 安装Vuex：npm install vuex --save
  + 在store文件夹中创建index.js文件，并在里面创建store对象
  + 首先导入vue和vuex插件，接着安装插件：Vue.use(Vuex)；然后创建一个store对象，最后就是导出该对象将它挂载到Vue实例上
  + 初始化完成之后就可以开始给vuex传入数据了，这里需要注意的是，在传值的过程中，不要直接就去修改state中的数据，而是应该通过mutations来操作state中的数据，所以这里在mutations中创建一个方法addCart，让Detail组件在提交数据时调用该方法
  ```
  import Vue from "vue"
  import Vuex from "vuex"
  // 1.安装插件
  Vue.use(Vuex)
  // 2.创建store对象
  const store = new Vuex.Store({
    state: {
      cartList: []
    },
    mutations: {  
      // mutations唯一的目的就是修改state中的状态
      // mutations中的每个方法尽可能完成的事件比较单一一点 
      addCart(state, payload) {
        // payload:指新添加的商品
        // 方式一：
        // let oldProduct = null;
        // 数组常用的方法有哪些？ push/pop/shift/unshift/sort/reverse/map/join/filter/reduce/find
        // 遍历已经添加到cartList中的商品
        // for (let item of state.cartList) {
        //   // 判断传过来的商品的iid是否有和已经添加到cartList中的商品的iid一致的情况
        //   // 如果有的话，就将该商品取出来，然后在下面给数量加一
        //   // 如果没有的话，就直接给新商品数量加一，然后将该商品push到cartList数组中
        //   if (item.iid === payload.iid) {
        //     oldProduct = item;
        //   }
        // }
        
        // 方式二：
        let oldProduct = state.cartList.find(item => item.iid === payload.iid);

        if (oldProduct) {
          oldProduct.count += 1;
        } else {
          payload.count = 1;
          state.cartList.push(payload)
        }
      }
    },
  })
  // 3.将Vuex挂载到Vue实例上
  export default store
  ```
  + Detail组件在调用时只需commit该方法即可
  ```
  this.$store.commit("addCart", product);
  ```

### 31.Vuex中的代码的重构
  + 为了更好地管理代码，以及能够使用vuex追踪状态，所以将代码进行重构
  + 因为mutations的唯一目的就是修改state中的状态，并且它里面的每个方法最好都尽可能完成的事件比较单一一点，所以我们可以将原来里面的判断逻辑移动到actions中来执行，然后通过actions来访问mutations，从而起到修改state中的状态
  ```
  mutations: {
    // mutations唯一的目的就是修改state中的状态
    // mutations中的每个方法尽可能完成的事件比较单一一点 
    addCounter(state, payload) {
      payload.count++;
    },
    addToCart(state, payload) {
      state.cartList.push(payload)
    }
  },
  actions: {
    addCart(context, payload) {
      let oldProduct = context.state.cartList.find(item => item.iid === payload.iid);

      if (oldProduct) {
        context.commit('addCounter', oldProduct);
      } else {
        payload.count = 1;
        context.commit('addToCart', payload);
      }
    }
  }
  ```
  + 同时又考虑到，如果将所有的代码都写在store文件夹下的index.js文件中，这样在后期一旦代码变得非常多时，管理起来是非常不方便的，所以采用官方的建议，将代码进行拆分，分模块进行存放，并且将函数名称用常量来表示，这样后期修改会非常方便，只需改动一个地方就行了
  ```
  <!-- mutauions.js -->
  import {ADD_COUNTER, ADD_TO_CART} from "./mutations_type"
  export default  {
    [ADD_COUNTER](state, payload) {
      payload.count++;
    },
    [ADD_TO_CART](state, payload) {
      state.cartList.push(payload)
    }
  }
  <!-- actions.js -->
  import {ADD_COUNTER, ADD_TO_CART} from "./mutations_type"
  export default {
    addCart(context, payload) {
      let oldProduct = context.state.cartList.find(item => item.iid === payload.iid);

      if (oldProduct) {
        context.commit(ADD_COUNTER, oldProduct);
      } else {
        payload.count = 1;
        context.commit(ADD_TO_CART, payload);
      }
    }
  }
  <!-- mutations_type.js -->
  export const ADD_COUNTER = "add_counter"
  export const ADD_TO_CART = "add_to_cart"
  <!-- index.js -->
  import Vue from "vue"
  import Vuex from "vuex"
  import mutations from "./mutations"
  import actions from "./actions"
  // 1.安装插件
  Vue.use(Vuex)
  const state = {
    cartList: [],
  }
  // 2.创建store对象
  const store = new Vuex.Store({
    state,
    mutations,
    actions
  })
  // 3.将Vuex挂载到Vue实例上
  export default store
  ```
  + Detail组件在调用时只需dispatch该方法即可
  ```
  this.$store.dispatch("addCart", product);
  ```

# 第四步：制作购物车视图
### 32.购物车导航栏的制作
  + 在view文件夹下创建cart文件夹，用来存放购物车视图相关的组件
  + 在Cart.vue组件中导入先前封装好的导航栏组件NavBar，给该组件设置样式背景颜色
  + 由效果图可知，这里只需要给NavBar组件的中间插槽插入对应内容即可，所以直接写上“购物车()”就好了
  + 由之前的vuex可知，在state中有一个cartList属性，里面存放的是加入到购物车中的商品的数量，所以我们只需要在Cart组件中获取到该属性的长度即可，即“购物车({{$store.state.cartList.length}})”
  + 考虑到直接在括号中写这么长的参数不是很合适，所以可以使用一个计算属性来获取
  ```
  <nav-bar class="cart-nav-bar">
      <div slot="middle">购物车({{cartLength}})</div>
  </nav-bar>

  computed: {
    cartLength() {
      return this.$store.state.cartList.length;
    }
  }
  ```
  + 但是这样写也还不是很全面，因为会考虑到不止这一个地方会使用到这个cartList的length，所以可以在store文件夹下写一个getters.js文件，在里面来计算需要用到的值
  ```
  export default {
    cartLength(state) {
      return state.cartList.length;
    }
  }
  ```
  + 在store文件夹下的index.js文件中导入getters.js文件，在Cart.vue组件中调用getters.js中的内容，这里可以使用vuex的辅助函数来实现调用，他的作用是将store中的getter映射到局部计算属性
  ```
  computed: {
    // 第一种语法，指定需要将哪些getters转换成计算属性（数组方式，表示是一一对应关系，名字是不变的）
    // ...mapGetters(['cartLength']),
    // 第二种语法，指定需要将哪些getters转换成计算属性（对象方式，表示是一一对应关系，名字是可变的）
    ...mapGetters({ length: "cartLength" }),
  },
  ```

### 33.购物车商品列表的展示
  + 这里我们将购物车页面大体分为三个部分，导航栏、商品列表、底部汇总；
  + 新建Cart组件的子组件CartList，用来存放所有添加到购物车中的商品；从效果图可知，商品列表是由一个个的商品信息组成的，所以可以再建个子组件，用来展示每个商品的信息，这里创建CartListItem组件，用来存放每个商品的信息；
  + 获取商品列表的信息可以通过vuex获得，方法同之前一样，在获取到商品的列表信息后就选择通过遍历的方式来动态决定要添加多少个CartListItem组件，并且由于需要在CartListItem中需要展示该商品的数据信息，所以需要将item传递到子组件中，在子组件中创建一个变量用来保存
  + 为了方便滚动，需要在CartList组件中导入Scroll组件，并在CartList组件中设置好视口的高度，并且为了保证点击跳转到购物车页面时的可滚动区域的高度计算正确，还应该需要在activated函数中调用Scroll组件的refresh方法
  ```
  <div class="cart-list">
    <scroll class="scroll" ref="bscroll">
      <cart-list-item
        v-for="(item, index) in cartList"
        :key="index"
        :product="item"
      ></cart-list-item>
    </scroll>
  </div>

  activated() {
    this.$refs.bscroll.refresh();
  }

  .cart-list {
    height: 100vh;
  }

  .scroll {
    position: absolute;
    top: 44px;
    bottom: 0;
    left: 0;
    right: 0;
  }
  ```

### 34.购物车商品列表item的展示
  + 在CartListItem组件中实现具体某个商品的展示，这里将一个商品展示行划分为三列，最左侧是一个单选框，接着是商品的图片，最右侧是商品的信息
  + 对于单选框来说，可以选择封装成一个单独的组件，因为后面可能会在其他地方用到它。这里在components/content文件夹下创建文件夹checkButton，里面包含CheckButton.vue组件
  + 这里实现单选框的方法是选择用一张透明背景的单选框图片来实现，通过监听该图片是否被点击了，来决定是否给图片附上一个class属性，该属性会让图片变色，从而到达选中的目的
  ```
  <template>
    <div class="check-button" :class="{check: isChecked}">
      <img src="~assets/img/cart/tick.svg" alt="" />
    </div>
  </template>

  <script>
  export default {
    name: "CheckButton",
    props: {
      isChecked: {
        type: Boolean,
        default: false
      }
    }
  };
  </script>

  <style scoped>
  .check-button {
    border-radius: 50%;
    border: 2px solid #aaa;
  }

  .check {
    border-color: red;
    background-color: red;
  }
  </style>
  ```

### 35.item选中和不选中的切换
  + 如何实现选中和不选中的状态切换呢？这里通过改变isChecked的状态来实现
  + 通过修改商品模型来修改isChecked的状态，这里在Detail.vue组件中给商品添加一个属性，让商品在添加到购物车时就默认保持选中状态（product.checked=true）；然后在CartListItem.vue组件中获取到它的父组件CartList.vue传给它的值itemInfo
  + 在CheckButton组件中将itenInfo.checked的值传递给子组件CheckButton，并监听该组件的点击事件（这里可以选择在外层监听，也可以进到CheckButton组件中监听，监听到了点击事件之后再通过自定义事件发送出来，在CartLiatItem组件中监听那个自定义事件，并在这里修改itemInfo.checked的值）
  ```
  <div class="item-selector">
      <CheckButton
        @click.native="checkBtnClick"
        :is-checked="itemInfo.checked"
      ></CheckButton>
  </div>

  methods: {
    checkBtnClick() {
      this.itemInfo.checked = !this.itemInfo.checked;
    }
  }
  ```

### 36.购物车底部工具栏的封装和应用
  + 创建一个CartBottomBar组件，用来显示购物车底部的工具栏，该工具栏可划分为三块，左侧的全选框，中间的价格计算部分，右侧的去计算价格部分
  + 这里仍然需要用到CheckButton组件，将它导入并使用，然后按照效果图进行布局，设置css样式
  ```
  <template>
    <div class="bottom-bar">
      <div class="check-content">
        <check-button class="check-button"></check-button>
        <span>全选</span>
      </div>
      <div class="price">合计：{{ totalPrice }}</div>
      <div class="calculate">去计算：({{ checkLength }})</div>
    </div>
  </template>

  <style scoped>
  .bottom-bar {
    background-color: #eee;
    position: absolute;
    bottom: 49px;
    display: flex;
    height: 40px;
    width: 100%;
    line-height: 40px;
    font-size: 15px;
  }

  .check-content {
    display: flex;
    align-items: center;
    margin-left: 5px;
    width: 70px;
  }

  .check-button {
    width: 20px;
    height: 20px;
    line-height: 20px;
  }

  .check-content span {
    margin-left: 10px;
  }

  .price {
    flex: 1;
    text-align: center;
  }

  .calculate {
    width: 90px;
    color: #eee;
    text-align: center;
    background-color: tomato;
  }
  </style>
  ```
  + 这里通过两个计算属性来实现获取商品的总共价格和去计算的商品数量
  ```
  computed: {
    totalPrice() {
      return (
        "￥" +
        this.$store.state.cartList
          .filter((item) => {
            return item.checked;
          })
          .reduce((preValue, item) => {
            return preValue + item.price * item.count;
          }, 0)
      );
    },
    checkLength() {
      return this.$store.state.cartList.filter((item) => item.checked).length;
    },
  },
  ```
  + 全选按钮的状态显示
    - 首先需要明确的是，如果全选按钮处于选中的状态时，那么意味着添加进商品列表的商品一定是处于被选中的状态，即 product.checked=true，如果状态处于未选中的状态，那么就意味着这些商品中至少有一件商品是处于未选中的状态；所以此时就可以通过这个条件来判断全选按钮在什么时候处于一个什么状态
    ```
    <div class="check-content">
      <check-button
        class="check-button"
        :is-checked="isSelectAll"
      ></check-button>
      <span>全选</span>
    </div>
    computed: {
      isSelectAll() {
        if (this.$store.state.cartList.length === 0) return false;
        // 方式一：使用高阶函数 find 来实现查找过滤
        return !this.$store.state.cartList.find((item) => !item.checked);

        // 方式二：使用高阶函数 filter 来实现查找过滤
        // return !this.$store.state.cartList.filter((item) => !item.checked).length;

        // 方式三：使用普通的遍历来查找过滤
        // for (let item of this.$store.state.cartList) {
        //   if (!item.checked) {
        //     return isChecked;
        //   }
        // }
        // return true;
      },
    },
    ```
  + 全选按钮的点击效果
    - 如果原来都是选中，点击一次，就变成全部都不选中
    - 如果原来都是不选中（或某些不选中），点击一次，则变成全部都选中
    - 通过监听点击事件来判断处于什么状态
    ```
    <div class="check-content">
      <check-button
        class="check-button"
        :is-checked="isSelectAll"
        @click.native="checkBtnClick"
      ></check-button>
      <span>全选</span>
    </div>
    
    methods: {
      checkBtnClick() {
        // 
        if (this.isSelectAll) {
          // 全部选中
          this.$store.state.cartList.forEach((item) => (item.checked = false));
        } else {
          // 部分或全部不选中
          this.$store.state.cartList.forEach((item) => (item.checked = true));
        }
      },
    },
    ```

### 37.Vuex-actions返回Promise，并且将Vuex中的actions中的方法映射到组件中（mapActions）
  + 为了能够知道是否成功将商品添加到购物车中了，这里需要用到Promise函数，即可以在actions方法中返回一个Promise，通过reslove接口向外界发送添加成功的标志，然后在调用的地方接收该标志即可
  ```
  <!-- actions.js -->
  addCart(context, payload) {
    return new Promise((reslove, reject) => {
      // 1.查找之前数组中是否有该商品
      let oldProduct = context.state.cartList.find(item => item.iid === payload.iid);

      // 2.有的话就将商品数量加一
      if (oldProduct) {
        context.commit(ADD_COUNTER, oldProduct);
        reslove('当前的商品数量+1')
      } else {// 没有的话就就将该商品加到购物车列表中
        payload.count = 1;
        context.commit(ADD_TO_CART, payload);
        reslove('添加了新的商品')
      }
    })
  }

  <!-- Detail.vue -->
  addToCart() {
    this.$store.dispatch("addCart", product).then((res) => {
        // 添加成功
        console.log(res);
      });
  }
  ```
  + 通过Vuex中自带的mapActions，将里面的方法映射到这里，这里就可以直接使用该方法了，不需要在通过diapatch()的方式来操作
  ```
  <!-- Detail.vue -->
  import { mapActions } from "vuex";

  methods: {
    ...mapActions(['addCart']),
    addToCart() {
      const product = {};
      product.image = this.topImages;
      product.title = this.goods.title;
      product.desc = this.detailInfo.desc;
      product.price = this.goods.realPrice;
      product.iid = this.iid;
      product.checked = true;

      this.addCart(product).then((res) => {
        console.log(res);
      });
    }
  }
  ```

### 38.Toast的封装-普通方式封装
  + 用组件的方式来实现，首先创建一个组件Toast，用来显示点击添加到购物车按钮后的弹窗。这个弹窗的样式也很简单，内容只有一句话，就是在调用addCart函数之后返回的res的内容，并且这里需要实现当弹窗出现了一两秒之后，会自动消失掉，这里可以用 v-show 来判断是否要将这个弹窗隐藏，至于 v-show 的值则是通过在调用toast组件的地方传过来的值来决定
  ```
  <!-- Toast.vue -->
  <template>
    <div class="toast" v-show="show">
      <div>{{ message }}</div>
    </div>
  </template>

  <script>
  export default {
    name: "Toast",
    props: {
      message: {
        type: String,
        default: "",
      },
      show: {
        type: Boolean,
        default: false,
      },
    },
  };
  </script>

  <style scoped>
  .toast {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 10px 15px;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.7);
  }
  </style>
  ```
  + 调用Toast组件，首先需要导入该组件并在components中注册，接着将Toast需要的值传进去，所以说这里就又需要用两个变量来保存这些值，接下来就需要在addCart中给这些变量赋值了
  ```
  <!-- Detail.vue -->
  <template>
    <div id="detail">
      <toast :message="toastMessage" :show="toastShow"></toast>
    </div>
  </template>
  <script>
  import Toast from "components/common/toast/Toast";
  export default {
  data() {
    return {
      toastMessage: "",
      toastShow: false,
    };
  },
  methods: {
    ...mapActions(["addCart"]),
    addToCart() {
      const product = {};
      product.image = this.topImages;
      product.title = this.goods.title;
      product.desc = this.detailInfo.desc;
      product.price = this.goods.realPrice;
      product.iid = this.iid;
      product.checked = true;

      this.addCart(product).then((res) => {
        this.toastShow = true;
        this.toastMessage = res;

        setTimeout(() => {
          this.toastShow = false;
          this.toastMessage = "";
        }, 2000);
      });
    }
  }
  </script>
  ```

### 39.Toast的封装-插件方式封装
  + 由上面的封装方式可以看出，用组件的方式来封装是非常麻烦的事，而且如果有多个地方需要用到Toast弹窗，那么就需要按照组件的使用方式在多个组件中重写多次，这样是非常麻烦的，所以这里采用更简洁的插件封装方式
  + 首先在toast目录下建立一个index.js文件，它的用处是用来导出组件对象以便于其它地方使用
  ```
  import Toast from "./Toast"
  const toastObj = {}
  toastObj.install = function (Vue) {
    // 1.创建组件构造器
    const toastContrustor = Vue.extend(Toast)
    // 2.new的方式，根据组件构造器，可以创建出来一个组件对象
    const toast = new toastContrustor()
    // 3.将组件对象，手动挂载到某一个元素上
    toast.$mount(document.createElement('div'))
    // 4.toast.$el对应的就是div
    document.body.appendChild(toast.$el)
    Vue.prototype.$toast = toast
  };
  export default toastObj
  ```
  + 然后需要在main.js中导入并注册使用，这样其他地方才能通过 this.$toast 访问到Toast组件中的属性和方法
  ```
  import toastObj from "components/common/toast"
  Vue.use(toastObj)
  ```
  + 由于这里采用插件方式封装，所以之前按照组件的写法就不适用了，将其全部删除掉，这里选择在Toast组件中实现，由于不需要父组件在给子组件传值了，所以不需要写props，这里用data变量来保存即可，同样，对于这个弹窗的显示与否也放到methods方法中来实现
  ```
  <template>
    <div class="toast" v-show="isShow">
      <div>{{ message }}</div>
    </div>
  </template>
  <script>
  export default {
    name: "Toast",
    data() {
      return {
        message: "",
        isShow: false,
      };
    },
    methods: {
      show(message, time) {
        this.isShow = true;
        this.message = message;

        setTimeout(() => {
          this.isShow = false;
          this.message = "";
        }, time);
      },
    },
  };
  </script>
  ```
  + 最后只需要在addCart这个接口中调用 this.$toast.show(res, 2000) 即可

### 40.fastClick-解决移动端300ms延迟
  + 安装fastclick：npm install fastclick --save
  + 在main.js中导入该插件并使用
  ```
  import FastClick from 'fastclick'
  FastClick.attach(document.body)
  ```

### 41.图片的懒加载-vue-lazyload框架
  + 目的：当图片需要显示在屏幕上时，再去加载图片
  + 使用步骤：
    - 安装：npm install vue-lazyload --save
    - main.js中导入：import VueLazyLoad from 'vue-lazyload'
    - main.js中使用： 
    ```
    <!-- 这里传了一个对象，该对象里面可以包含多种参数，这里是传了一张占位符图片，即在图片没有被加载时，就用这个占位符图片来代替 -->
    <!-- 具体可传参数见Github：https://github.com/hilongjw/vue-lazyload -->
    Vue.use(VueLazyLoad, {
      loading: reuqire('./assets/img/common/placeholder.png')
    })
    ```
    - 此时图片标签的图片加载就不再是之前的“:src='image'”了，而是应该写成“v-lazy='image'”的形式，例如将GoodsListItem组件中的图片加载换成懒加载

### 42.px2vw-css单位转化插件
  + 使用步骤：
    - 安装：npm install postcss-px-to-viewport --save-dev
    - 直接使用插件，但需要在postcss.config.js中配置
    ```
    module.exports = {
      plugins: {
        autoprefixer: {},
        "postcss-px-to-viewport": {
          viewportWidth: 375,   // 视窗的宽度，对应的是我们设计稿的宽度
          viewportHeight: 667,  // 视窗的高度，对应的是我们设计稿的高度（也可以不配置）
          unitPrecision: 5,     // 指定“px”转换为视窗单位值的小数位数（很多时候无法整除）
          viewportUnit: 'vw',   // 指定需要转换成的视窗单位，建议使用vw
          selectorBlackList: ['ignore','tab-bar','tab-bar-item'],   // 指定不需要转换的类
          minPixelValue: 1,     // 小于或等于“1px”不转换为视窗单位
          mediaQuery: false,    // 允许在媒体查询中转换“px”
          exclude: [/TabBar/],  // 指定不需要转换的类
        }
      }
    }
    ```
    - 上面的宽度和高度是基于iphone6的宽高来设计的
    - 在js中使用正则表达式：/正则相关规则/
    - exclude中存放的元素必须是正则表达式
    - 按照需要排除的文件来写对应的正则
    - 正则的规则：
      - 1> ^abc: 表示匹配的内容，必须以什么内容开头（即以abc开头）
      - 2> abc$：表示匹配的内容，必须以什么内容结尾（即以abc结尾）

### 43.nginx-项目在windows下的部署
  + 服务器：就是一台电脑（只不过没有显示器，就是一台主机），24小时开机，为用户提供服务
  + 操作系统：windows/Linux
  + 服务器中的软件：tomcat/nginx
  + 将自己的电脑作为服务器：windows上装nginx服务器（官网：nginx.org）
  + nginx版本的分类（大致可分为三类）：
    - Mainline version：Mainline是Nginx目前的主力在做的版本，可以说是开发版
    - Stable version：最新稳定版，生产环境建议使用的版本
    - Legacy version：遗留的老版本的稳定版
  + 这里在官网选择稳定版下载并解压，然后双击解压后的nginx.exe启动该服务器
  + 在项目中运行：npm run build 打包项目，生成一个文件夹dist，然后将dist目录拷贝到nginx的安装目录中，这里有两种方式可以实现读取dist：
    - 方式一：将原来html文件夹中的文件删除，然后将dist文件夹中的内容拷贝到html文件夹中，因为nginx的配置文件中，默认是去读取html文件夹中的index.html文件的
    - 方式二：将dist文件夹拷贝到nginx安装目录后，直接去修改conf下的nginx.conf配置文件，将里面的默认读取文件夹html改成dist即可，然后在任务管理器中找到该进程，杀掉后重启即可。

### 44.nginx-项目在远程linux下部署
  + 步骤：
    - 更新并安装Nginx：sudo apt-get update sudo apt-get install nginx
    - 安装完成后，Nginx服务将自动启动，检查服务的状态：sudo systemctl status nginx
    - 要停止Nginx服务，运行：sudo systemctl stop nginx
    - 要重新启动，运行：sudo systemctl start nginx
    - 重新启动Nginx服务，运行：sudo systemctl restart nginx
    - 进行一些配置更改后，要重新加载Nginx服务，运行：sudo systemctl reload nginx
    - 默认情况下，Nginx服务将在启动时启动，如果要禁用Nginx服务以在启动时启动：sudo systemctl disable nginx，然后并重新启用：sudo systemctl enable nginx 
  + 配置文件位置：/etc/nginx目录中

### 45.响应式原理
 + 详情见 01-vue的响应式原理.html 以及 02-vue的响应式原理.png