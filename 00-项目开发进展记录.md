# 第一步：初始化工作
### 1、划分目录结构
  * assets：资源目录，一般包含img和css。
      normalize.css：是一种CSS reset的替代方案，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。
  
  * common：存放公共的.js文件，比如第三方库之类的

  * components：公共组件，下面可在细分为两个文件夹
      一个是common：指完全公共的组件，随便放到哪个项目中就能立即使用，不需要做任何修改
      一个是content：指对于该项目来说是公共的组件

  * network：网络请求相关

  * router：路由相关

  * store：状态管理相关

  * views：视图页面，用于存放该项目的不同模块中的视图

### 2、引入css文件
  * 创建最基本的base.css文件，在其中引入noamalize.css文件，然后在App.vue中导入base.css文件

### 3、配置别名
  * 对于脚手架2来说，需要在build文件夹中的 webpack.base.conf.js 文件中配置：
    ```
    resolve: {
      alias: {
        '@': resolve('src');
        'assets': resolve('src/assets'),
        'components': resolve('src/components'),
        'views': resolve('src/views'),
      }
    }
    ```

  * 对于脚手架3来说，需要在最外层目录中创建一个 vue.config.js 文件，在里面配置：
    ```
    module.exports = {
      configureWebpack: {
        resolve: {
          // extensions: ['.js', '.vue', '.json'],  // 对于脚手架3来说，不用在配置这个选项，默认创建时就已经配置好了(.js,.vue,.json)
          alias: {
            // '@': resolve('src'),   // 默认已经配置好了
            'assets': '@/assets',
            'common': '@/common',
            'components': '@/components',
            'network': '@/network',
            'views': '@/views',
          }
        }
      }
    }
    ```

### 4、为了便于项目中的样式的统一，需要在最外层目录中添加一个 .editorconfig 文件，用来限制样式
    ```
    root = true

    [*]
    charset = utf-8
    indent_style = space
    indent_size = 2
    end_of_line = lf
    insert_final_newline = true
    trim_trailing_whitespace = true
    ```

# 第二步：导入之前创建好的tabbar组件
### 1.添加组件
  * 在components文件夹中创建目录，common/tabbar，里面包含两个组件(TabBar.vue和TabBarItem.vue)
  * 在components文件夹中创建目录，content/maintabbar，里面包含一个组件(MainTabBar.vue)

### 2.导入组件
  * 在App.vue中导入tabbar的最外层组件 MainTabBar (import MainTabBar from 'components/content/maintabbar/MainTabBar')
  * 将MainTabBar组件在components中注册一下，在template模板中加入<main-tab-bar></main-tab-bar>标签

### 3.在views文件夹中创建多个视图目录，主要由tabbar里面包含的模块决定
  * 比如此项目就包含4个模块，分别是home(首页),category(分类),cart(购物车),profile(我的)

### 4.创建路由
  + 在router文件夹中创建index.js文件
    + 基本步骤
      - 1.先导入基本的vue和vue-router 
      - 2.安装插件(Vue.use(VueRouter))
      - 3.定义路由，配置路由映射
          ```
          const routes= [
            {
              path: '',
              redirect: '/home' // 路由重定向，目的是为了使网页一打开就能显示首页内容
            },
            {
              path: '/home',
              component: Home
            },
            ...
          ]
          ```
      - 4.定义路由对象
          ```
          const router = new VueRouter({
            routes,
            mode: 'history',
          })
          ```
      - 5.导出路由对象
    + 将views中的视图模块(路由懒加载方式)导入，以便在定义路由时使用
      ```
      const Home = () => import('views/home/Home')
      const Category = () => import('views/category/Category')
      ...
      ```

### 5.导入路由
  + 在main.js文件中导入路由并且将它添加到全局的Vue实例中
  + 在App.vue的template中添加标签<router-view></router-view>

# 第三步：制作首页视图
### 1.创建导航栏组件
  + 由于大多数的移动端的导航栏组件基本类似，都大致可划分为3块，即左右两个固定宽度的标签以及中间剩余部分的文字标签。所以可以将它封装成一个完全独立的组件。
  + 在components/common目录下创建一个navbar文件夹，创建组件NavBar.vue
  + 由于要做到可以随意设置导航栏里的内容，所以采用插槽的方式设置
  + 由于直接对插槽进行样式设置不太合理，所以在每个插槽外面单独封装一个div给它包裹起来，对div进行样式设置
  + 对导航栏采用flex布局
    ```
    .nav-bar {
      display: flex;
      height: 44px;   // 导航栏的高度一般都为44px
      line-height: 44px;
      text-align: center;
      box-shadow: 0 1px 1px rgba(100, 100, 100, 0.1); // 给div设置阴影
    }

    .left,
    .right {
      width: 60px;
    }

    .middle {
      flex: 1;
    }
    ```
### 2.在首页视图中使用导航栏组件
  + 在views/home目录下的Home.vue组件中导入导航栏组件
    import NavBar from 'components/common/navbar/NavBar';
  + 将该组件在components中注册
  + 给该导航栏插入对应的内容
    - 由于该首页导航栏只有中间部分有内容，所以只需要一个标签插入即可,将它绑定到对应的插槽上
      <nav-bar class="home-nav">
        <div slot="middle">购物街</div>
      </nav-bar>
  + 为了保证导航栏组件的独立性，不选择直接在导航栏组件中设置背景颜色样式，而是在引入nav-bar组件的地方，给组件添加一个class属性，用来单独设置
    ```
    .home-nav {
      background-color: var(--color-tint);
      color: #fff;
    }
    ```
### 3.首页视图向服务器请求数据
  + 知识点：函数调用过程
    - 函数调用 -> 压入函数栈（保存函数调用过程中的所有变量）
    - 函数调用结束 -> 弹出函数栈（释放函数所有的变量，即内存会被回收掉）
  + 1.先将之前封装好的request.js文件拷贝到network目录下
  + 2.为了保证每个页面请求的数据不会混乱，所以可以选择为每个页面单独建立请求文件
  + 3.建立home.js文件，在里面封装一个用来请求首页所有数据的函数接口（getHomeMultidata）
  + 4.在Home.vue中导入封装好的home.js
  + 5.因为我们需要在页面一打开就有数据出来，所以可以在生命周期钩子created()中调用数据请求接口，
    即保证在页面一加载就执行程序获得数据
  + 6.由于getHomeMultidata返回的是一个Promise，所以可以在.then()中获取到请求的数据
  + 7.为了能够保证数据一直存在，所以用一个变量来保存它（在data中声明一个变量）
  + 8.为了能使首页中的各模块数据好区分开来，所以可以用多个变量分别来保存
  + 9.此时主要是请求的轮播图和推荐信息的数据
  
### 4.首页轮播图界面的展示
  + 1.因为轮播图算是一个公共组件，所以在components下common目录下创建swiper文件夹
  + 2.创建一个Swiper.vue组件：该组件表示轮播图最外层的容器；
      创建一个SwiperItem.vue组件：该组件表示轮播图中的每个元素，这里指图片
  + 3.在Home组件中导入Swiper，SwiperItem组件并在components中注册组件
    ```
    // import Swiper from "components/common/swiper/Swiper";
    // import SwiperItem from "components/common/swiper/SwiperItem";
    import { Swiper, SwiperItem } from "components/common/swiper"; // 这里导入的其实是index.js文件中export出来的模块
    ```
  + 4.由于需要动态更新元素，所以采用插槽的方式传值
    - 在Swiper组件中有两个插槽，第一个插槽是用来传入图片的插槽，这里我们会在Home组件中调用Swiper时给它传入SwiperItem组件，在SwiperItem组件中会传入一个超链接a，确保在点击图片后能够跳转到对应界面，然后在a标签中添加一个img标签，用来显示图片;另一个插槽“indicator”是用来动态更新图片中间下方的白色小圆点，它会根据有几张图片加载进来来动态创建小圆点并将小圆点与对应的图片进行绑定
    - 由于需要做到动态更新，不能写死，所以采用v-for来遍历之前请求到的轮播图数据,动态创建<swiper-item>组件
    - ```
      <swiper>
        <swiper-item v-for="item in banners">
          <a :href="item.link">
            <img :src="item.image" alt="" />
          </a>
        </swiper-item>
      </swiper>
      ```
  + 5.为了避免Home组件中的代码逻辑变得更复杂，便于后期维护与阅读，所以可以将swiper组件在进行一次封装，封装成HomeSwiper组件。由于封装的HomeSwiper组件只是为了在home中使用，所以可以直接在views/home目录下在创建一个文件夹childComponents用来存放只属于home页面中的组件，没必要到最外层的components目录下创建
  + 6.在HomeSwiper组件中调用Swiper组件和SwiperItem组件
    ```
    <template>
      <swiper>
        <swiper-item v-for="item in banners">
          <a :href="item.link">
            <img :src="item.image" alt="" />
          </a>
        </swiper-item>
      </swiper>
    </template>

    <script>
    // import Swiper from "components/common/swiper/Swiper";
    // import SwiperItem from "components/common/swiper/SwiperItem";
    import { Swiper, SwiperItem } from "components/common/swiper";

    export default {
      name: "HomeSwiper",
      props: {  // 由于本身是没有banners参数的，所以需要靠父组件给它传递
        banners:  {
          type: Array,
          default() {
            return []
          }
        }
      },
      components: {
        Swiper,
        SwiperItem,
      }
    };
    </script>

    <style>
    </style>
    ```
  + 7.在Home组件中调用HomeSwiper组件，并将请求到的轮播图数据传递给子组件HomeSwiper
    ```
    <template>
      <div id="home">
        <nav-bar class="home-nav"><div slot="middle">购物街</div></nav-bar>
        <home-swiper :banners="banners"></home-swiper>
      </div>
    </template>
    ```

### 5.首页推荐信息界面的展示
  + 1.在childComponents目录下创建子组件HomeRecommendView
  + 2.在Home组件中导入HomeRecommendView组件
  ```
  import HomeRecommendView from "./childComponents/HomeRecommendView";
  ```
  + 3.在HomeRecommendView组件中添加如下标签，为了避免层级太多，代码过于复杂，采用v-for来遍历数组，动态创建多个推荐信息标签
    ```
    <template>
      <div class="recommend">
        <div class="recommend-item" v-for="item in recommends">
          <a :href="item.link">
            <img :src="item.image" alt="">
            <div>{{item.title}}</div>
          </a>
        </div>
      </div>
    </template>
    ```
  + 4.给标签recommend-item设置样式，这里采用水平均匀分布
  + 5.由于v-for遍历的recommends中的内容是在父组件Home中请求的，所以这里需要父组件将recommends的数据传递给子组件HomeRecommendView，同时在子组件中应该建立props属性来接父组件传过来的值
  ```
  <script>
  export default {
    name: "HomeRecommendView",
    props: {
      recommends: {
        type: Array,
        default() {
          return []
        }
      }
    }
  }
  </script>
  ```
  + 6.Home组件中调用HomeRecommendView组件，并将recommends数据传递到子组件
  ```
  <template>
    <div id="home">
      <nav-bar class="home-nav"><div slot="middle">购物街</div></nav-bar>
      <home-swiper :banners="banners"></home-swiper>
      <home-recommend-view :recommends="recommends"></home-recommend-view>
    </div>
  </template>
  ```

### 6.首页本周流行界面的展示
  + 1.创建组件HomeFeatureView
  + 2.由项目的最终演示成果可知，本周流行这部分展示的其实是一张图片，并不是一个个小的组件组成的，所以直接在模板中添加一个根标签div，在根标签中再加一个img标签即可；但是由于当点击图片之后，界面会跳转到本周流行的商品界面中，所以说，不能单纯的加一个img标签就好了，这里我们选择在img的外层套一个a标签，这样点击图片后就能跳转了
  ```
  <template>
    <div class="feature">
      <a href="https://act.mogujie.com/zzlx67">
        <img src="~assets/img/home/recommend_bg.jpg" alt="" />
      </a>
    </div>
  </template>
  ```
  + 3.在Home组件中导入HomeFeatureView组件并使用
  + 4.从显示效果可以看出，图片大小太大，超出了屏幕界限，所以在HomeFeatureView组件中设置图片的样式
  + 5.此时图片已经能够正常显示，点击也会正常跳转
  + 6.此时滚动右侧的滑动条会发现，当我们在向下滚动时，最上方的导航栏组件也会一起滑动，从而被隐藏，这与我们的初衷就不符合了，本意是想让它一直固定在最上方，不随滑动条的滚动而滚动
  + 7.所以在Home组件中设置导航栏的样式，将它的位置改为固定不移动
  ```
  .home-nav {
      background-color: var(--color-tint);
      color: #fff;

      position: fixed;
      left: 0;
      right: 0;
      top: 0;
  }
  ```
  + 8.设置位置之后，navbar会被轮播图的图片给挡住，从而不可见，所以需要在样式中设置层级：z-index:9
  + 9.设置层级之后，导航栏组件能显示出来，但是可以发现它会遮盖一下轮播图组件，所以我们给最外层的根标签设置样式：padding-top：44px；即让它距离顶部的间距和导航栏组件的高度一致，这样就能正常显示了。
  + 10.为了能够看到本周流行界面下方的内容，这里可以简单的添加一个无序列表来占位，便于查看滚动的时候，之前设置的样式有没有生效。

### 7.首页tabControl界面的展示
  + 1.对于本周流行界面下方的tabControl界面来说，这是一个可以重复利用的组件，因为在分类页面中也可以复用，只需要重新替换下里面的文本内容即可。所以选择将tabControl组件独立出来，放到components文件夹下，又因为这个组件会偏向于只针对该项目，所以将它放在components/content目录下，做成一个对于该项目来说独立的组件
  + 2.创建完TabControl组件后，这里可以有两种选择方式；第一种就是采用插槽的方式，类似导航栏组件的做法，写上3个插槽；第二种写法就是用div嵌套span标签的方式来实现
  + 3.使用v-for来遍历父组件传过来的titles的内容，动态创建3个嵌套了span标签的div
  ```
  <div class="tab-control">
    <div v-for="item in titles">
      <span>{{ item }}</span>
    </div>
  </div>

  <!-- script中写入 -->
  props: {
    titles: {
      type: Array,
      default() {
        return [];
      },
    },
  },
  ```
  + 4.Home组件中导入TabControl组件并使用，给子组件传入相应的值
  ```
  <tab-control class="tab-control" :titles="['流行','新款','精选']"></tab-control>
  ```
  + 5.打开网页，可以看见已经能够显示出来了，下面就需要调整样式了。给子组件添加一个class属性“item-tab-control”，设置它的样式以及它的根元素的样式
  ```
  .tab-control {
    display: flex;
    text-align: center;
    font-size: 15px;
    background-color: #fff;
  }

  .tab-control-item {
    flex: 1;
    height: 40px;
    line-height: 40px;
  }
  ```
  + 6.样式正常后，接下来该实现选中文本标签后颜色的改变以及画出文本下方的横线，对于横线，可以采用css的boder-bottom属性，即设置一个底边的样式就可以实现
  + 7.由于要实现颜色的改变，这里给每个标签添加一个index属性，这样就可以根据选中标签时的下标来判断到底哪个标签该变成粉色，所以在遍历时需要做一些改变，同时添加一个class属性“active”来判断到底哪个标签被激活，通过判断标签的index和当前的currentIndex是否一致来决定是否给该标签所属的div添加一个active属性
  ```
  <div class="tab-control">
    <div
      v-for="(item, index) in titles"
      class="tab-control-item"
      :class="{ active: index == currentIndex }"
      @click="itemClick(index)"
    >
      <span>{{ item }}</span>
    </div>
  </div>

  data() {
    return {
      currentIndex: 0,
    };
  },
  methods: {
    itemClick(index) {
      this.currentIndex = index;
    }
  }

  .tab-control-item span {//为了避免下方横线离文本太近，添加一个间距
    padding: 5px;
  }

  .active {
    color: var(--color-high-text);
  }

  .active span {
    border-bottom: 2px solid var(--color-tint);
  }
  ```
  + 8.此时，当我们滚动页面时，其它一切正常，但是会发现tabControl也会随着一起滚动，与我们想要的效果不符，这里我们可以使用css的position：sticky以及top：44px来实现将tabControl固定在离顶部44px的位置，不再随着页面滚动而隐藏掉。但是后期会选择用其它方式来实现，因为有些浏览器对position的这个属性不兼容。

### 8.请求首页商品列表（流行、新款、精选）的数据
  + 1.由于商品列表的数据非常多，为了避免重复请求带来的性能浪费，所以选择一次性的请求全部数据，用一个对象变量（goods）来保存它们。
    - 因为里面的数据分为了三大块，所以在goods里面创建了三个对象，分别用来保存对应模块的数据内容
    - 在各自模块中又创建了两个键值，page和list，list是个数组，主要用来存放对应的数据，page是页码，用来判断当前页面显示了几页的数据（这里我们假设一页默认含有30个商品数据，，如果我们滑到最底部后不再选择下拉加载新的数据时，就只会显示30个商品数据，如果选择了下拉加载新的数据，此时page就变成2，list中的数据就会变成两页的商品数据，即60个商品）
    - 同时加上一个page键值的目的也是为了区分开不同模块的加载数量，比方说pop页加载的page为3，则list应为[90]；new页加载的page为2，则list应为[60]；sell页加载的page为1，则list应为[30]；这样当我们在三个页面中来回切换时，就可以明确的知道请求了多少的数据量，不必再频繁的点击一个页面就去请求一次数据。这里我们只需要做到在一个页面有下拉刷新的行为时才会去请求一次数据
  + 2.由于要请求数据了，所以可以在网络请求模块中再重新封装一个函数接口，用来请求商品数据；因为需要知道具体请求的是哪个页面的内容以及请求多少页的内容，所以需要保证该函数有两个传参（type，page）
  ```
  export function getHomeGoods(type, page) {
    return request({
      url: 'home/data',
      params: {
        type,
        page
      }
    })
  }
  ```
  + 3.在Home组件中导入该函数接口，并在created钩子函数中实现
  + 4.因为需要做到在页面一加载就将流行/精选/新款的第一页内容获取到，所以这里需要调用三次函数接口
  ```
  getHomeGoods('pop', 1).then((res) => {console.log(res)}
  getHomeGoods('new', 1).then((res) => {console.log(res)}
  getHomeGoods('sell', 1).then((res) => {console.log(res)}
  ```
  + 5.如果像上面这样直接在created中调用接口，如果次数较少到是无所谓，但当次数一旦频繁起来，就会使得代码逻辑变得复杂冗余，所以可以选择对这些请求函数的接口在封装一层方法，将它们都放到methods中实现，只需要在created中调用本身的方法即可
  ```
  created() {
    // 1.请求多个数据
    this.get_home_multidata();
    // 2.请求商品数据
    this.get_home_goods("pop");
    this.get_home_goods("new");
    this.get_home_goods("sell");
  },
  methods: {
    get_home_multidata() {
      getHomeMultidata().then((res) => {
        this.banners = res.data.banner.list;
        this.recommends = res.data.recommend.list;
      });
    },

    get_home_goods(type) {
      const page = this.goods[type].page + 1;
      getHomeGoods(type, page).then((res) => {
        // 方法一
        // for (let n of res.data.list) {
        //   this.goods[type].list.push(n);
        // }
        // 方法二
        // ...可以将数组中的数据解析遍历，并一个一个的取出来
        this.goods[type].list.push(...res.data.list);
        this.goods[type].page += 1;
      });
    },
  }
  ```
  + 6.此时可以对方法进行上述的封装，主要是为了实现类型和页数的动态指定。
    - 在getHomeGoods被执行前，获取到属于该类型的页码，对其进行加一，目的是为了动态指定页数（由于默认获取的页数是第0页，所以此时获取的就是第一页的内容）
    - 在getHomeGoods被执行后，获取到属于该类型的页码，对其进行加一，此时page就变成了1，这样在执行后续的下拉刷新时，就可以获取到第二页的内容了，同时由于之前获取到的第一页的内容已经push到list数组中了，所以在获取了第二页内容后，将它们push追加到list数组中即可

### 9.商品列表数据的展示
  + 1.考虑到组件的复用性，选择将组件创建在components/content目录下，目的是为了能够在该项目中多处复用。
  + 2.创建一个最外层的大组件GoodsList，然后里面会嵌套多个小组件GoodsListItem
  + 3.通过Home组件给GoodsList组件传入数据，在GoodsList组件中动态创建GoodsListItem组件，用v-for来遍历传过来的goods，根据goods的大小来决定创建几个GoodsListItem组件，同时将遍历出来的item传给GoodsListItem子组件，这里item是个对象（Object）
  + 4.在GoodsListItem组件中实现具体的显示，由最终效果图可知，里面含有一个img标签用来显示图片，一个p标签用来显示对图片的描述，一个span标签用来显示价格，一个span标签用来显示被收藏的数量
  ```
  <template>
    <div class="goods-item">
      <img :src="goodsItem.show.img" alt="" srcset="" />
      <div class="goods-info">
        <p>{{ goodsItem.title }}</p>
        <span class="price">{{ goodsItem.price }}</span>
        <span class="collect">{{ goodsItem.cfav }}</span>
      </div>
    </div>
  </template>

  <script>
  export default {
    name: "GoodsListItem",
    props: {
      goodsItem: {
        type: Object,
        default() {
          return {};
        },
      },
    },
  };
  </script>
  ```
  + 5.此时信息已经能够显示了，接下来设置样式。
    - 先设置最外层的样式，这里设置图片与该组件的下边界的距离为44px，即表示图片下方用来显示信息的文字区域的高度为44px，同时给它设置相对定位布局，方便后面文字的绝对定位布局，如果不设置相对定位的话，那么后面文字的绝对定位则是根据窗口的位置来设置的
    ```
    .goods-item {
      padding-bottom: 40px;
      position: relative;
    }
    ```
    - 设置图片的样式，宽度100%填充，高度自适应，为了好看，加一个圆角
    ```
    .goods-item img {
      width: 100%;
      border-radius: 5px;
    }
    ```
    - 接着设置下方文字显示区域的样式，这里采用绝对定位，使得它能够依据之前设定的相对定位来找位置
    ```
    .goods-info {
      font-size: 12px;
      position: absolute;
      bottom: 5px;
      left: 0;
      right: 0;
      overflow: hidden;
      text-align: center;
    }
    ```
    - 设置p标签的样式，让它能够显示在一行里面，超出一行的用...给它隐藏起来
    ```
    .goods-info p {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-bottom: 3px;
    }
    ```
    - 设置价格的样式，这里主要是字体颜色以及价格标签的一个位置
    ```
    .goods-info .price {
      color: var(--color-high-text);
      margin-right: 20px;
    }
    ```
    - 设置收藏标签的样式，这里对整个标签采用相对布局，对标签里的伪元素图标采用绝对定位
    ```
    .goods-info .collect {
      position: relative;
    }

    /* 采用伪元素的方式，引入一个收藏图标 */
    .goods-info .collect::before {
      content: "";
      position: absolute;
      left: -15px;
      top: -1px;
      width: 14px;
      height: 14px;
      background: url("~assets/img/common/collect.svg") 0 0/14px 14px;
    }
    ```
  + 6.为了达到美观效果，这里一行只显示两个GoodsListItem，所以可以采用flex布局。justify-content 属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间
  ```
  .goods {
    /* 由于直接采用flex布局的话，默认是会挤在一行显示，不换行 */
    display: flex;
    /* 这里使用flex-wrap：wrap 表示允许换行，再结合给子组件设定的宽度48%就可以达到换行效果 */
    flex-wrap: wrap;
    /* 均匀排列每个元素，每个元素周围分配相同的空间 */
    justify-content: space-around;
    padding: 2px;
  }

  .goods-item {
    /* padding-bottom:指一个元素在内边距区域（指一个元素的内容与边框之间的区域）中下方的高度 */
    padding-bottom: 40px;
    position: relative;
    width: 48%;
  }
  ```